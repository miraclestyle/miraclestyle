{"ts":1379095584344,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"# -*- coding: utf-8 -*-\n'''\nCreated on Jul 12, 2013\n\n@author:  Edis Sehalic (edis.sehalic@gmail.com)\n'''\n\nimport webapp2\nimport six\nimport os\nimport sys\nimport logging\nimport json\n \nfrom jinja2 import FileSystemLoader\n\nfrom app import settings\n\n\"\"\"\n Systemic helper functions that are more python-related in their nature\n\"\"\"\n\nclass JSONEncoderForHTML(json.JSONEncoder):\n    \"\"\"An encoder that produces JSON safe to embed in HTML.\n\n    To embed JSON content in, say, a script tag on a web page, the\n    characters &, < and > should be escaped. They cannot be escaped\n    with the usual entities (e.g. &amp;) because they are not expanded\n    within <script> tags.\n    \"\"\"\n  \n    def iterencode(self, o, _one_shot=False):\n        chunks = super(JSONEncoderForHTML, self).iterencode(o, _one_shot)\n        for chunk in chunks:\n            chunk = chunk.replace('&', '\\\\u0026')\n            chunk = chunk.replace('<', '\\\\u003c')\n            chunk = chunk.replace('>', '\\\\u003e')\n            yield chunk\n \n\ndef logger(msg, t=None):\n    if t == None:\n       t = 'info'\n       \n    if settings.DO_LOGS:\n       getattr(logging, t)(msg)\n \n\ndef _resolve_name(name, package, level):\n    \"\"\"Return the absolute name of the module to be imported.\"\"\"\n    if not hasattr(package, 'rindex'):\n        raise ValueError(\"'package' not set to a string\")\n    dot = len(package)\n    for x in range(level, 1, -1):\n        try:\n            dot = package.rindex('.', 0, dot)\n        except ValueError:\n            raise ValueError(\"attempted relative import beyond top-level \"\n                              \"package\")\n    return \"%s.%s\" % (package[:dot], name)\n\n\ndef import_module(name, package=None):\n    \"\"\"Import a module.\n\n    The 'package' argument is required when performing a relative import. It\n    specifies the package to use as the anchor point from which to resolve the\n    relative import to an absolute import.\n\n    \"\"\"\n    if name.startswith('.'):\n        if not package:\n            raise TypeError(\"relative imports require the 'package' argument\")\n        level = 0\n        for character in name:\n            if character != '.':\n                break\n            level += 1\n        name = _resolve_name(name[level:], package, level)\n    __import__(name)\n    return sys.modules[name]\n\ndef module_exists(module_name):\n    try:\n       logger('Loading module: ' + module_name)\n       module = import_module(module_name)\n    except ImportError:\n        return False\n    else:\n        return module\n    \n\n_BOOT_CONFIG = None\n  \ndef boot(as_tuple=False):\n    \n    global _BOOT_CONFIG\n    \n    if _BOOT_CONFIG:\n       if not as_tuple:\n          return _BOOT_CONFIG\n       return tuple(_BOOT_CONFIG.items())\n    \n     \n    \"\"\"\n      Main boot, consists of loading urls.py from every installed application, and builds theme file paths\n    \"\"\"\n    \n    if not six.PY3:\n        fs_encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()\n      \n    ROUTES = []\n    JINJA_FILTERS = {}\n    JINJA_GLOBALS = {}\n    TEMPLATE_DIRS = []\n      \n    for a in settings.APPLICATIONS_INSTALLED:\n        import_module('%s.%s' % (a, 'models')) # import all models for ndb mapper\n        module_manifest = import_module('%s.%s' % (a, 'manifest'))\n        if module_manifest:\n            template_dir = os.path.join(os.path.dirname(module_manifest.__file__), 'templates')\n            if os.path.isdir(template_dir):\n               if not six.PY3:\n                  template_dir = template_dir.decode(fs_encoding)\n               TEMPLATE_DIRS.append(template_dir)\n               \n            routes = getattr(module_manifest, 'ROUTES', None)\n            filters = getattr(module_manifest, 'JINJA_FILTERS', None)\n            jinja_globals = getattr(module_manifest, 'JINJA_GLOBALS', None)\n            \n            if jinja_globals:\n               for g in jinja_globals:\n                   JINJA_GLOBALS[g[0]] = g[1]\n            \n            if filters:\n               for f in filters:\n                   if isinstance(f, dict):\n                      JINJA_FILTERS[f['name']] = f['filter']\n                   elif callable(f):\n                      JINJA_FILTERS[f.__name__] = f\n                   elif isinstance(f, tuple):\n                      JINJA_FILTERS[f[0]] = f[1]\n            \n            if routes:\n               ROUTES += routes\n                \n               \n    # It won't change, so convert it to a tuple to save memory.           \n    ROUTES = tuple(ROUTES)       \n    TEMPLATE_DIRS = tuple(TEMPLATE_DIRS)\n    JINJA_GLOBALS.update({'uri_for' : webapp2.uri_for, 'ROUTES' : ROUTES, 'settings' : settings})\n    TEMPLATE_LOADER = FileSystemLoader(TEMPLATE_DIRS)\n    \n    logger('Webapp2 started, compiling stuff')\n    \n    JINJA_CONFIG = {}\n    JINJA_CONFIG.update(settings.WEBAPP2_EXTRAS)\n    JINJA_CONFIG['webapp2_extras.jinja2'] = {\n                 'template_path': 'templates',\n                 'globals' : JINJA_GLOBALS,\n                 'filters' : JINJA_FILTERS,\n                 'environment_args': {\n                   'extensions': ['jinja2.ext.i18n', 'jinja2.ext.autoescape', 'jinja2.ext.loopcontrols'],\n                   'autoescape' : True, \n                   'loader' : TEMPLATE_LOADER,\n                   'cache_size' : settings.TEMPLATE_CACHE\n         }\n    }\n    \n    _BOOT_CONFIG = dict(JINJA_CONFIG=JINJA_CONFIG,\n                        ROUTES=ROUTES,\n                        JINJA_GLOBALS=JINJA_GLOBALS,\n                        JINJA_FILTERS=JINJA_FILTERS,\n                        TEMPLATE_DIRS=TEMPLATE_DIRS,\n                        TEMPLATE_LOADER=TEMPLATE_LOADER\n                       )\n    if not as_tuple:\n       return _BOOT_CONFIG\n    else:\n       return tuple(_BOOT_CONFIG.items())"]],"start1":0,"start2":0,"length1":0,"length2":5702}]],"length":5702}
