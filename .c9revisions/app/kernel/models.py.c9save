{"ts":1380711145260,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"# -*- coding: utf-8 -*-\n'''\nCreated on Jul 9, 2013\n\n@author:  Edis Sehalic (edis.sehalic@gmail.com)\n'''\nfrom webapp2_extras import sessions\n\nfrom app import settings, ndb\nfrom app.memcache import temp_memory_get, temp_memory_set\nfrom app.core import logger\n\nclass WorkflowTransitionError(Exception):\n      pass\n  \nclass WorkflowStateError(Exception):\n      pass\n  \nclass WorkflowActionError(Exception):\n      pass\n  \nclass WorkflowBadStateCode(Exception):\n      pass\n\nclass WorkflowBadActionCode(Exception):\n      pass\n  \nclass PermissionError(Exception):\n      pass\n  \nclass PermissionDenied(Exception):\n      pass\n\nclass PermissionBadValue(Exception):\n      pass \n \nclass Workflow():\n    \n      OBJECT_DEFAULT_STATE = False\n      OBJECT_STATES = {}\n      OBJECT_TRANSITIONS = {}\n      OBJECT_ACTIONS = {}\n      \n      @classmethod\n      def default_state(cls):\n        # returns default state for this model\n        return cls._resolve_state_code_by_name(cls.OBJECT_DEFAULT_STATE)[0]\n  \n      @classmethod\n      def _resolve_state_code_by_name(cls, state_code):\n          \"\"\"\n          @return tuple (int, str)\n          \"\"\"\n          codes = cls.OBJECT_STATES\n          code = codes.get(state_code)\n          if not code:\n             raise WorkflowStateError('This model does not have state code %s, while available %s' % (state_code, codes))\n          return code\n      \n      @classmethod\n      def _resolve_action_code_by_name(cls, st):\n          \"\"\"\n          @return str\n          \"\"\"\n          actions = cls.OBJECT_ACTIONS\n          action = actions.get(st, None)\n          if action == None:\n             raise WorkflowActionError('Unexisting action called %s, while available %s' % (st, actions))\n          return action\n      \n      @classmethod\n      def _resolve_action_name_by_code(cls, code):\n          \"\"\"\n          @return int\n          \"\"\"\n          for k, v in cls.OBJECT_ACTIONS.items():\n              if v == code:\n                 return k\n          raise WorkflowBadActionCode('Bad action coded provided %s, possible names %s' % (code, cls.OBJECT_ACTIONS.keys()))  \n      \n      @classmethod\n      def _resolve_state_name_by_code(cls, code):\n          \"\"\"\n          @return str\n          \"\"\"\n          for k, value in cls.OBJECT_STATES.items():\n              if value[0] == code:\n                 return k\n          raise WorkflowBadStateCode('Bad state code provided %s, possible names %s' % (code, cls.OBJECT_STATES.keys()))  \n      \n      def resolve_state(self, new_state_code):\n          code, transition_name = self._resolve_state_code_by_name(new_state_code)\n          state = self.state\n          \n          # if the state is changing\n          if code != state:\n             transitions = self.OBJECT_TRANSITIONS\n             transition = transitions.get(transition_name)\n             \n             if (self._resolve_state_name_by_code(state) not in transition['from']) or (new_state_code not in transition['to']):\n                raise WorkflowTransitionError('You cannot move this object from state %s to %s according to %s transition config.' % (state, new_state_code, transitions))\n             else:\n                return new_state_code\n          return code\n \n      def new_state(self, state, action, **kwargs):\n          \n          # if `state` is None, use the object's current state\n          if state == None:\n              state = self._resolve_state_name_by_code(self.state)\n               \n          if not isinstance(action, int):\n             action = self._resolve_action_code_by_name(action)\n\n          async = kwargs.pop('_async', None)\n          objlog = ObjectLog(state=self.resolve_state(state), action=action, parent=self.key, **kwargs)\n\n          if not async:   \n             return objlog.put()\n          else:\n             return objlog.put_async()\n \n      def format_permission(self, permission):\n          # generator for permissions based on Entity provided\n          # it is required that permission is action defined in `self.OBJECT_ACTIONS`\n          if not isinstance(permission, (tuple, list)):\n             permission = (permission, )\n             \n          permission = list(permission)\n          \n          actions = self.OBJECT_ACTIONS.keys()\n          \n          if self.has_complete_key():\n             state = self.state\n          else:\n             state = self.default_state()\n          \n          for p in permission:\n              if p not in actions:\n                 raise PermissionBadValue('Provided permission `%s` not common with object `%s`, possible permissions are `%s`' % (p, self.__class__.__name__, actions))\n          \n          repack = []\n          for p in permission:\n              # permission (action)_state_model\n              repack.append('%s_%s_%s' % (p, self._resolve_state_name_by_code(state), self.__class__.__name__.lower()))\n              \n          return tuple(repack)\n          \n      @property\n      def logs(self):\n          return ObjectLog.query(ancestor=self.key)\n \n\nclass UserIdentity(ndb.BaseModel):\n    \n    _KIND = 2\n    # StructuredProperty model\n    identity = ndb.StringProperty('1', required=True)# spojen je i provider name sa id-jem\n    email = ndb.StringProperty('2', required=True)\n    associated = ndb.BooleanProperty('3', default=True)\n    primary = ndb.BooleanProperty('4', default=True)\n    \nclass User(ndb.BaseExpando, Workflow):\n    \n    _KIND = 0\n    \n    OBJECT_DEFAULT_STATE = 'active'\n  \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state         \n        'active' : (1, 'activate'),\n        'suspended' : (2, 'suspend'),\n    }\n \n    OBJECT_ACTIONS = {\n       'register' : 1,\n       'update' : 2,\n       'login' : 3,\n       'logout' : 4,\n       'suspend' : 5,\n       'activate' : 6\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'activate' : {\n             # from where to where this transition can be accomplished?\n            'from' : ('suspend',),\n            'to' : ('active',)\n         },\n        'suspend' : {\n            # suspend can go from active to suspend\n           'from' : ('active', ),\n           'to'   : ('suspend',)\n        },\n    }\n     \n    state = ndb.IntegerProperty('1', required=True, verbose_name=u'Account State')\n    emails = ndb.StringProperty('2', repeated=True)# soft limit 100x\n    identities = ndb.StructuredProperty(UserIdentity, '3', repeated=True)# soft limit 100x\n    \n    _default_indexed = False\n  \n    @classmethod\n    def _auth_or_anon_role(cls, what):\n        k = getattr(settings, 'USER_%s_KEYNAME' % what.upper())\n        return Role.get_by_id(k, use_memcache=True, use_cache=True)\n        \n    @classmethod\n    def _auth_or_anon(cls, what):\n        k = getattr(settings, 'USER_%s_KEYNAME' % what.upper())\n        u = cls._get_from_memory(ndb.Key(User, k).urlsafe())\n        dic = isinstance(u, dict)\n        \n        if not u or not u.has_key('self'):\n           # renew the cache\n           u = cls.get_by_id(k)\n           if u:\n              u.aggregate_user_permissions()\n              u._self_make_memory({}, True)\n              return u\n            \n           # anon or auth user does not exist? create it (install sequence) \n           @ndb.transactional(xg=True)\n           def trans(ob, k, what): \n               u = ob(state=ob.default_state(), id=k)\n               u.put()\n               \n               perms = getattr(settings, 'USER_%s_PERMISSIONS' % what.upper())\n               role = Role(permissions=perms, id=k, name='%s Users' % what.lower().capitalize())\n               role.put()\n               \n               user_role = RoleUser(parent=role.key, user=u.key, state=RoleUser._resolve_state_code_by_name('accepted')[0])\n               user_role.put()\n               \n               return u\n           \n           user = trans(cls, k, what)\n           user.aggregate_user_permissions()\n           \n           up = {}\n           if dic:\n              up = u\n           user._self_make_memory(up, True)\n           return user\n       \n        return u['self']\n    \n    # DRY\n      \n    @classmethod\n    def authenticated_user(cls):\n        return cls._auth_or_anon('AUTHENTICATED')\n    \n    @classmethod\n    def anonymous_user(cls):\n        return cls._auth_or_anon('ANONYMOUS')\n    \n    @classmethod\n    def authenticated_user_role(cls):\n        return cls._auth_or_anon_role('AUTHENTICATED')\n    \n    @classmethod\n    def anonymous_user_role(cls):\n        return cls._auth_or_anon_role('ANONYMOUS')\n    \n    def aggregate_user_permissions(self):\n        return self._aggregate_user_permissions(self)\n \n    @classmethod\n    def _aggregate_user_permissions(cls, user):\n        \n        # aggregates user permissions based on `user`, accepts user.key or user as param\n        if not isinstance(user, ndb.Key):\n           user = user.key\n            \n        roles_ = RoleUser.query(RoleUser.user==user, RoleUser.state==RoleUser._resolve_state_code_by_name('accepted')[0])\n        \n        logger('aggregate user perms %s, roles: %s' % (user, roles_))  \n        \n        @ndb.tasklet\n        def callback(user_role):\n          role_perms = yield user_role.key.parent().get_async()\n          raise ndb.Return((user_role, role_perms))\n      \n        roles = roles_.map(callback)\n        \n        permission_makeup = {}\n        for r in roles:\n            role = r[1]\n            rparent = role.key.parent()\n            if not rparent:\n               rparent = role.key\n            reference_key = rparent.urlsafe()\n            perms = role.permissions\n            aperms = permission_makeup.get(reference_key)\n            if aperms:\n               perms = perms + aperms \n            \n            permission_makeup[reference_key] = set(perms)\n                \n        fs = AggregateUserPermission.query(ancestor=user).fetch()\n        \n        keys = permission_makeup.keys()\n        to_delete = list()\n        puts_fs = list()\n        \n        for f in fs:\n            reference_key = f.reference.urlsafe()\n            if reference_key not in keys:\n               to_delete.append(f.key)\n            else:\n               xp = permission_makeup.get(reference_key)\n               if xp:\n                   f.permissions = xp\n                   puts_fs.append(f)\n                   del permission_makeup[reference_key]\n  \n        puts = []\n        for k, v in permission_makeup.items():\n            puts.append(AggregateUserPermission(parent=user, permissions=v, reference=ndb.Key(urlsafe=k)))\n            \n        puts = puts_fs + puts\n        \n        @ndb.transactional\n        def puts_all(puts, to_delete):\n            if len(puts):\n               ndb.put_multi(puts)\n            \n            if len(to_delete):\n               ndb.delete_multi(to_delete)\n               \n        puts_all(puts, to_delete)\n               \n    def logout(self):\n        self._self_clear_memcache()\n       \n    @property\n    def primary_email(self):\n        for i in self.identities:\n            if i.primary:\n               return i.email\n           \n        return 'N/A'\n  \n    @staticmethod\n    def current_user_is_guest():\n        u = User.get_current_user()\n        return u.is_guest\n    \n    @staticmethod\n    def current_user_is_logged():\n        u = User.get_current_user()\n        return u.is_logged\n     \n    # some shorthand aliases\n    @property\n    def is_logged(self):\n        return self.key.id() != settings.USER_ANONYMOUS_KEYNAME\n    \n    @property\n    def is_guest(self):\n        return self.key.id() == settings.USER_ANONYMOUS_KEYNAME\n\n    # but can use all other methods\n    \n    @staticmethod\n    def set_current_user(u):\n        logger('setting new user %s' % u)\n        temp_memory_set('user', u)\n         \n    @staticmethod\n    def get_current_user():\n        \"\"\"\n        @return `User`\n        \"\"\"\n        u = temp_memory_get('user', None)\n        if u == None:\n            logger('get_current_user')\n            sess = sessions.get_store().get_session(backend=settings.SESSION_STORAGE)\n            if sess.has_key(settings.USER_SESSION_KEY):\n               u = sess[settings.USER_SESSION_KEY].get()\n               if not u:\n                  u = User.anonymous_user()\n            else:\n               u = User.anonymous_user()\n            temp_memory_set('user', u)\n             \n        return u\n    \n    current = get_current_user\n     \n    def new_state(self, state, action, **kwargs):\n        return super(User, self).new_state(state, action, agent=self.key, **kwargs)\n  \n    def has_permission(self, obj=None, permission_name=None, strict=False, _raise=False):\n        return self._has_permission(self, obj, permission_name, strict, _raise)\n    \n    @classmethod\n    def _has_permission(cls, user, obj=None, permission_name=None, strict=False, _raise=False, **kwargs):\n        \"\"\"\n        \n        Can be called as `User._has_permission(user_key....)` as well\n        \n        Params\n        `obj` = Entity.key or Entity\n        `permission_name` = list, tuple or str\n        `strict` = require that all provided permissions need to be checked\n        \n        Usage...\n        \n        user = User.get_current_user()\n \n        if user.has_permission(store_key, 'store_edit') \n        \n        or multiple (if any found)\n        \n        if user.has_permission(store_key, ['catalog_create', 'catalog_publish'])\n        \n        or multiple strict mode (must have all of them)\n        \n        if user.has_permission(store_key, ['catalog_create', 'catalog_publish'], True)\n        \n        this could also be done by choosing between tuple () and [] to determine if it will be strict, but thats debatable\n  \n        returns mixed, depending on permission_name==None\n        \"\"\"\n        \n        is_callback = callable(permission_name)\n          \n        # to prevent recursion\n        auth = kwargs.get('_check_authenticated', False)\n        guest = kwargs.get('_check_guest', False)\n        \n        if not user:\n           raise Exception('Invalid user provided')\n \n        if user.is_logged and not auth: \n           response = cls._has_permission(User.authenticated_user(), obj, permission_name, strict, False, _check_authenticated=True)\n           if response == True:\n              return True\n          \n        if user.is_guest and not guest:\n           response = cls._has_permission(User.anonymous_user(), obj, permission_name, strict, _raise, _check_guest=True)\n           return response\n       \n        # do not format it because we are providing callbacks\n        if not is_callback:\n            if obj:  \n                if hasattr(obj, 'format_permission'):\n                   permission_name = obj.format_permission(permission_name)\n                else:\n                   raise PermissionError('obj `%s` provided, is not instance of `Workflow`' % obj)\n            else:\n                if not isinstance(permission_name, (list, tuple)):\n                   permission_name = (permission_name,) \n       \n        ex = PermissionDenied('Not allowed, because you do not have permission(s): `%s`' % permission_name)  \n        \n        if not isinstance(user, ndb.Key):\n           user = user.key\n        \n        # make sure we get the correct permissions for authenticated specific and guest specific\n        if auth or guest:\n           if auth:\n              obj = User.authenticated_user_role()\n           if guest:\n              obj = User.anonymous_user_role()\n        \n        if obj:\n           obj = obj.key\n \n        logger('checking if user %s has permissions %s upon object %s' %  (user.id(), permission_name, obj.urlsafe()))\n   \n        memory = User._get_from_memory(user.urlsafe())\n  \n        if memory == None:\n           memory = {}\n        \n        if obj: \n           obj_id = obj.urlsafe()\n        else:\n            if _raise:\n               raise ex\n            else:\n               return False\n        \n        if not memory.has_key('permissions'):\n           memory['permissions'] = {}\n              \n        if not memory['permissions'].has_key(obj_id):\n           ag_ = AggregateUserPermission.query(AggregateUserPermission.reference==obj, ancestor=user).get()\n           if not ag_:\n              perms = []\n           else:\n              perms = ag_.permissions\n           ag = memory['permissions'][obj_id] = perms\n           User._make_memory(user, memory)\n        else:\n           ag = memory['permissions'].get(obj_id)\n           \n        # free variable\n        del memory\n            \n        if not ag:\n           if _raise:\n              raise ex\n           return False\n        \n        # if we want the callback to handle the things\n        if is_callback:\n           result = permission_name(obj, user)\n           if result:\n              return result\n           else:\n              if _raise:\n                 raise ex\n              else:\n                 return False\n        if ag:\n           if permission_name == None:\n              return ag\n           else: \n              response = strict \n              for p in permission_name:\n                  if strict:\n                     if p not in ag:\n                        response = False\n                        break\n                  else:\n                      if p in ag:\n                         response = True\n                         break\n              if not response:\n                 if _raise:\n                    raise ex\n              return response\n        else:\n           if _raise:\n              raise ex\n           return False\n   \nclass ObjectLog(ndb.BaseExpando):\n    \n    _KIND = 7\n    # ancestor Any\n    # reference i type izvlacimo iz kljuca - key.parent()\n    # posible composite indexes ???\n    logged = ndb.DateTimeProperty('1', auto_now_add=True)\n    agent = ndb.KeyProperty('2', kind=User, required=True)\n    action = ndb.IntegerProperty('3', required=True)\n    state = ndb.IntegerProperty('4', required=True)\n    \n    #_default_indexed = False\n    #message / m = ndb.TextProperty('5')# max size 64kb - to determine char count\n    #note / n = ndb.TextProperty('6')# max size 64kb - to determine char count\n    #log / l = ndb.TextProperty('7')\n    \n    # We use this define user-specific expando properties, without defining them in for each datastore put\n    # @see meth `BaseExpando.get_field`\n    _VIRTUAL_FIELDS = {\n       'message' : ndb.TextProperty('5', verbose_name=u'Message'),\n       'note' : ndb.TextProperty('6', verbose_name=u'Note'),\n       'log' : ndb.PickleProperty('7', verbose_name=u'Log'),\n    }\n \nclass UserIPAddress(ndb.BaseModel):\n    \n    _KIND = 3\n    # ancestor User\n    ip_address = ndb.StringProperty('1', required=True, indexed=False, verbose_name=u'IP Address')\n    logged = ndb.DateTimeProperty('2', auto_now_add=True, verbose_name=u'Logged On')\n\n\nclass Role(ndb.BaseModel):\n    \n    _KIND = 6\n    # ancestor Store (Any)\n    name = ndb.StringProperty('1', required=True, indexed=False, verbose_name=u'Role name')\n    permissions = ndb.StringProperty('2', repeated=True, indexed=False, verbose_name=u'Role permissions')# soft limit 1000x - permission_state_model - edit_unpublished_catalog\n    readonly = ndb.BooleanProperty('3', default=True, indexed=False, verbose_name=u'Readonly')\n    \nclass RoleUser(ndb.Model, Workflow):\n    \n    _KIND = 4\n    # ancestor Role\n    \n    OBJECT_DEFAULT_STATE = 'invited'\n\n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)         \n        'invited' : (3, 'accept'),\n        'accepted' : (4, 'accept'),\n        'declined' : (5, 'decline'),\n    }\n \n    OBJECT_ACTIONS = {\n       'invite' : 7,\n       'accept' : 8,\n       'decline' : 9,\n       'remove' : 10,\n    }\n \n    OBJECT_TRANSITIONS = {\n        'accept' : {\n             # from where to where this transition can be accomplished?\n            'from' : ('invited',),\n            'to' : ('accepted',)\n         },\n        'decline' : {\n            # suspend can go from active to suspend\n           'from' : ('invited', ),\n           'to'   : ('declined',)\n        },\n    }    \n    \n    user = ndb.KeyProperty('1', kind=User, required=True, verbose_name=u'User')\n    state = ndb.IntegerProperty('2', required=True, verbose_name=u'Invited/Accepted')# invited/accepted\n \n\nclass AggregateUserPermission(ndb.BaseModel):\n    \n    _KIND = 5\n    # ancestor User\n    reference = ndb.KeyProperty('1',required=True, verbose_name=u'Reference')# ? ovo je referenca na Role u slucaju da user nasledjuje globalne dozvole, tj da je Role entitet root\n    permissions = ndb.StringProperty('2', repeated=True, indexed=False, verbose_name=u'Permissions')# permission_state_model - edit_unpublished_catalog\n    "]],"start1":0,"start2":0,"length1":0,"length2":20604}]],"length":20604}
