{"ts":1378921097340,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1378921185716,"patch":[[{"diffs":[[1,"#coding=UTF-8\n\n#MASTER MODEL FILE\n\n# NAPOMENA!!! - Sve mapirane informacije koje se snimaju u datastore trebaju biti hardcoded, tj. u samom aplikativnom codu a ne u settings.py\n# u settings.py se cuvaju one informacije koje se ne cuvaju u datastore i koje se ne koriste u izgradnji datastore recorda...\n\n# pitanje je da li ce nam trebati composite indexi za query-je poput:\n# BuyerAddress.query(ancestor=key).order(BuyerAddress.name) ili AggregateUserPermission.query(AggregateUserPermission.reference == key, ancestor=key)\n# ali je highly unlikely, zato sto se ancestor ne mora ukljucivati u slucajevima composite indexa\n# odgovor na gore postavljeno pitanje se mozda moze pronaci na: \n# https://developers.google.com/appengine/docs/python/datastore/indexes#Python_Index_configuration\n# https://github.com/GoogleCloudPlatform/appengine-guestbook-python\n# za sada smo resili osnovne query-je sa composite indexima koji podrazumevaju ancestor filtere,\n# pa mozemo kasnije tokom razvoja funkcionalne logike to dalje unaprediti.\n\n# datastore ne podrzava LIKE statement kao sto to podrzavaju struktuirane baze, umesto LIKE se moze korititi index range scan, kao napr:\n# SELECT * FROM Country WHERE name >= 'B' AND name < 'C' ORDER BY name\n# mnogi modeli koji ce imati opciju pretraga po osnovu user custom entry-ja ce koristiti ovaj mehanizam,\n# i na njima se moraju pripremiti indexi za ove funkcije.\n\n# treba se ispitati \"_default_indexed = False\" za Expando modele\n\n# problem 1 write per sec unutar transakcija kojie se commitaju na jednu entity grupu se treba normalizovati.\n# ovaj problem se odnosi na broj write operacija koje se mogu odvijati na istoj entity grupi.\n# jedan primer gde ovaj problem moze postojati je u slucaju AggregateBuyerCollectionCatalog!!\n\n# detalji oko modeliranja podataka i skaliranja su prezentirani na dole navedenim linkovima\n# https://developers.google.com/appengine/articles/datastore/overview\n# https://developers.google.com/appengine/articles/scaling/overview\n\n# skontati idempotency modela koji ce ucestvovati u transakcijama (ovo je najbolje uraditi u fazi razvoja funkcionalne logike)\n# idempotency se odnosi na sve modele, i treba nastojati uciniti sve transakcije idempotent-ne, u najmanju ruku, kada je to moguce!\n\n'''\nOvo su zabranjena imena propertija:\n\nall\napp\ncopy\ndelete\nentity\nentity_type\nfields\nfrom_entity\nget\ngql\ninstance_properties\nis_saved\nkey\nkey_name\nkind\nparent\nparent_key\nproperties\nput\nsetdefault\nto_xml\nupdate\n'''\n\nfrom google.appengine.ext import blobstore\nfrom google.appengine.ext import ndb\nfrom decimal import *\n\n\nclass DecimalProperty(ndb.StringProperty):\n  def _validate(self, value):\n    if not isinstance(value, (decimal.Decimal)):\n      raise TypeError('expected an decimal, got %s' % repr(value))\n\n  def _to_base_type(self, value):\n    return str(value) # Doesn't matter if it's a decimal or string\n\n  def _from_base_type(self, value):\n    return decimal.Decimal(value)  # Always return a decimal\n\n################################################################################\n# User - \n################################################################################\n\n# done!\nclass User(ndb.Expando):\n    \n    # root\n    state = ndb.IntegerProperty('1', required=True)\n    emails = ndb.StringProperty('2', repeated=True)# soft limit 100x\n    identities = ndb.StructuredProperty(UserIdentity, '3', repeated=True)# soft limit 100x\n    _default_indexed = False\n    pass\n    #Expando\n    \n    _KIND = 2\n    \n    OBJECT_DEFAULT_STATE = 'active'\n    \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state\n        # Ne znam da li je predvidjeno ovde da moze biti vise tranzicija/akcija koje vode do istog state-a,\n        # sto ce biti slucaj sa verovatno mnogim modelima.\n        # broj 0 je rezervisan za none (Stateless Models) i ne koristi se za definiciju validnih state-ova\n        'active' : (1, ),\n        'suspended' : (2, ),\n    }\n    \n    OBJECT_ACTIONS = {\n       'register' : 1,\n       'update' : 2,\n       'login' : 3,\n       'logout' : 4,\n       'suspend' : 5,\n       'activate' : 6,\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'activate' : {\n             # from where to where this transition can be accomplished?\n            'from' : ('suspended',),\n            'to' : ('active',),\n         },\n        'suspend' : {\n           'from' : ('active', ),\n           'to'   : ('suspended',),\n        },\n    }\n    \n    # Ova akcija nastaje prilikom prve autentikacije kada korisnik nije jos registrovan.\n    # Ukoliko se prilikom \"login\" akcije ustanovi da korisnik nikada nije evidentiran u bazi, nastupa akcija \"register\". \n    @ndb.transactional\n    def register():\n        # ovu akciju moze izvrsiti samo neregistrovani neautenticirani agent.\n        user = User(state='active', emails=['user@email.com',], identities=[UserIdentity(identity='abc123', email='user@email.com', associated=True, primary=True),])\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent=user_key, action='register', state=user.state, log=user)\n        object_log.put()\n        # UserIPAddress se pravi nakon pravljenja ObjectLog-a zato sto se ne loguje.\n        user_ip_address = UserIPAddress(parent=user_key, ip_address='127.0.0.1')\n        user_ip_address.put()\n    \n    # Ova akcija radi insert/update/delete na neki prop. (izuzev state) u User objektu.\n    @ndb.transactional\n    def update():\n        user.emails = ['user@email.com',]\n        user.identities = [UserIdentity(identity='abc123', email='user@email.com', associated=True, primary=True),]\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent=user_key, action='update', state=user.state, log=user)\n        object_log.put()\n        # ukoliko se u listi user.identities promenio prop. user.identities.primary, \n        # radi se potraga za eventualnim BuyerCollection entietom usera koji je imao prethodnu email adresu, \n        # i radi se buyer_collection.primary_email prop.\n    \n    # Ova akcija se izvrsava svaki put kada neautenticirani korisnik stupi u proces autentikacije.\n    # Prvo se proverava da li je korisnik vec registrovan. Ukoliko User ne postoji onda se prelazi na akciju \"register\".\n    # Ukoliko user postoji, onda se dalje ispituje. \n    # Proverava se da li ima nekih izmena na postojecim podacima, i ukoliko ima, onda se poziva \"update\" akcija.\n    # Dalje se proverava da li je useru dozvoljen login (User.state == 'active'). Ako mu je dozvoljen login onda se izvrsava \"login\" akcija.\n    @ndb.transactional\n    def login():\n        # ovde bi mogla da stoji provera continue if(User.state == 'active'), ili van ove funkcije, videcemo.\n        object_log = ObjectLog(parent=user_key, agent=user_key, action='login', state=user.state)\n        object_log.put()\n        # UserIPAddress se pravi nakon pravljenja ObjectLog-a zato sto se ne loguje.\n        user_ip_address = UserIPAddress(parent=user_key, ip_address='127.0.0.1')\n        user_ip_address.put()\n    \n    # Ova akcija se izvrsava svaki put kada autenticirani korisnik stupi u proces deautentikacije.\n    @ndb.transactional\n    def logout():\n        object_log = ObjectLog(parent=user_key, agent='user_key/agent_key', action='logout', state=user.state)\n        object_log.put()\n    \n    # Ova akcija sluzi za suspenziju aktivnog korisnika, i izvrsava je privilegovani/administrativni agent.\n    # Treba obratiti paznju na to da suspenzija usera ujedno znaci i izuzimanje svih negativnih i neutralnih feedbackova koje je user ostavio dok je bio aktivan.\n    ''' Suspenzija user account-a zabranjuje njegovom vlasniku autenticirani pristup na mstyle, \n    i deaktivira sve negativne i neutralne feedback-ove koji su sa ovog user account-a ostavljeni. \n    Ni jedan asocirani email suspendovanog korisnickog racuna se vise ne moze upotrebiti na mstyle \n    (za otvaranje novog account-a, ili neke druge operacije). \n    Account koji je suspendovan se moze opet reaktivirati od strane administratora sistema. '''\n    @ndb.transactional\n    def suspend():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'suspend-User'.\n        # akcija se moze pozvati samo ako je user.state == 'active'.\n        user.state = 'suspended'\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent='agent_key', action='suspend', state=user.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n        # poziva se akcija \"logout\";\n        User.logout()\n    \n    # Ova akcija sluzi za aktiviranje suspendovanog korisnika i izvrsava je privilegovani/administrativni agent.\n    # Treba obratiti paznju na to da aktivacija usera ujedno znaci i vracanje svih negativnih i neutralnih feedbackova koje je user ostavio dok je bio aktivan, a koji su bili izuzeti dok je bio suspendovan.\n    # Aktivni user account je u potpunosti funkcionalan i operativan.\n    @ndb.transactional\n    def activate():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'activate-User'.\n        # akcija se moze pozvati samo ako je user.state == 'suspended'.\n        user.state = 'active'\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent='agent_key', action='activate', state=user.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n\n# done!\nclass UserIdentity(ndb.Model):\n    \n    # StructuredProperty model\n    identity = ndb.StringProperty('1', required=True)# spojen je i provider name sa id-jem\n    email = ndb.StringProperty('2', required=True)\n    associated = ndb.BooleanProperty('3', default=True)\n    primary = ndb.BooleanProperty('4', default=True)\n\n# done! mozemo li ovo da stavljamo u app engine log ? - ovo sam verovatno i ranje pitao...\nclass UserIPAddress(ndb.Model):\n    \n    # ancestor User\n    # not logged\n    # ako budemo radili per user istragu loga onda nam treba composite index: ancestor:yes - logged:desc\n    logged = ndb.DateTimeProperty('1', auto_now_add=True, required=True)\n    ip_address = ndb.StringProperty('2', required=True, indexed=False)\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],"start1":0,"start2":0,"length1":0,"length2":10353}]],"length":10353,"saved":false}
{"ts":1378921455158,"patch":[[{"diffs":[[0,"False)\n\n"],[-1,"\n"],[1,"################################################################################\n# BUYER - 4\n################################################################################\n\n# done!\nclass BuyerAddress(ndb.Expando):\n    \n    # ancestor User\n    # composite index: ancestor:yes - name\n    name = ndb.StringProperty('1', required=True)\n    country = ndb.KeyProperty('2', kind=Country, required=True, indexed=False)\n    city = ndb.StringProperty('3', required=True, indexed=False)\n    postal_code = ndb.StringProperty('4', required=True, indexed=False)\n    street_address = ndb.StringProperty('5', required=True, indexed=False)\n    default_shipping = ndb.BooleanProperty('6', default=True, indexed=False)\n    default_billing = ndb.BooleanProperty('7', default=True, indexed=False)\n    _default_indexed = False\n    pass\n    # Expando\n    # naredna dva polja su required!!!\n    # region = ndb.KeyProperty('8', kind=CountrySubdivision, required=True)# ako je potreban string val onda se ovo preskace \n    # region = ndb.StringProperty('8', required=True)# ako je potreban key val onda se ovo preskace\n    # street_address2 = ndb.StringProperty('9')\n    # email = ndb.StringProperty('10')\n    # telephone = ndb.StringProperty('11')\n    \n    _KIND = 18\n    \n    OBJECT_DEFAULT_STATE = 'none'\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'delete' : 3,\n    }\n    \n    # Pravi novu adresu korisnika\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        buyer_address = BuyerAddress(parent=user_key, name='Home', country='82736563', city='Beverly Hills', postal_code='90210', street_address='First Street, 10', region='656776533')\n        buyer_address_key = buyer_address.put()\n        object_log = ObjectLog(parent=buyer_address_key, agent=user_key, action='create', state='none', log=buyer_address)\n        object_log.put()\n    \n    # Azurira postojecu adresu korisnika\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_address.parent == agent).\n        buyer_address.name = 'Home in Miami'\n        buyer_address.country = '82736563'\n        buyer_address.city = 'Miami'\n        buyer_address.postal_code = '26547'\n        buyer_address.street_address = 'Second Street, 10'\n        buyer_address.region = '514133'\n        buyer_address_key = buyer_address.put()\n        object_log = ObjectLog(parent=buyer_address_key, agent=user_key, action='update', state='none', log=buyer_address)\n        object_log.put()\n    \n    # Brise postojecu adresu korisnika\n    @ndb.transactional\n    def delete():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_address.parent == agent).\n        object_log = ObjectLog(parent=buyer_address_key, agent=user_key, action='delete', state='none')\n        object_log.put()\n        buyer_address_key.delete()\n\n# done!\nclass BuyerCollection(ndb.Model):\n    \n    # ancestor User\n    # mozda bude trebao index na primary_email radi mogucnosti update-a kada user promeni primarnu email adresu na svom profilu\n    # composite index: ancestor:yes - name\n    name = ndb.StringProperty('1', required=True)\n    notifications = ndb.BooleanProperty('2', default=False)\n    primary_email = ndb.StringProperty('3', required=True, indexed=False)\n    \n    _KIND = 19\n    \n    OBJECT_DEFAULT_STATE = 'none'\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'delete' : 3,\n    }\n    \n    # Pravi novu kolekciju za korisnika\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        for identity in user.identities:\n            if(identity.primary == True):\n                user_primary_email = identity.email\n                break\n        buyer_collection = BuyerCollection(parent=user_key, name='Favorites', notifications=True, primary_email=user_primary_email)\n        buyer_collection_key = buyer_collection.put()\n        object_log = ObjectLog(parent=buyer_collection_key, agent=user_key, action='create', state='none', log=buyer_collection)\n        object_log.put()\n    \n    # Azurira postojecu kolekciju korisnika\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection.parent == agent).\n        buyer_collection.name = 'Shoes'\n        buyer_collection.notifications = True\n        for identity in user.identities:\n            if(identity.primary == True):\n                user_primary_email = identity.email\n                break\n        buyer_collection.primary_email = user_primary_email\n        buyer_collection_key = buyer_collection.put()\n        object_log = ObjectLog(parent=buyer_collection_key, agent=user_key, action='update', state='none', log=buyer_collection)\n        object_log.put()\n    \n    # Brise postojecu kolekciju korisnika\n    @ndb.transactional\n    def delete():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection.parent == agent).\n        object_log = ObjectLog(parent=buyer_collection_key, agent=user_key, action='delete', state='none')\n        object_log.put()\n        buyer_collection_key.delete()\n\n# done!\nclass BuyerCollectionStore(ndb.Model):\n    \n    # ancestor User\n    store = ndb.KeyProperty('1', kind=Store, required=True)\n    collections = ndb.KeyProperty('2', kind=BuyerCollection, repeated=True)# soft limit 500x\n    \n    _KIND = 20\n    \n    OBJECT_DEFAULT_STATE = 'none'\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'delete' : 3,\n    }\n    \n    # Dodaje novi store u korisnikovu listu i odredjuje clanstvo u kolekcijama korisnika\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        buyer_collection_store = BuyerCollectionStore(parent=user_key, store='7464536', collections=['1234'])\n        buyer_collection_store_key = buyer_collection_store.put()\n        object_log = ObjectLog(parent=buyer_collection_store_key, agent=user_key, action='create', state='none', log=buyer_collection_store)\n        object_log.put()\n        # izaziva se update AggregateBuyerCollectionCatalog preko task queue\n    \n    # Menja clanstvo store u kolekcijama korisnika\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection_store.parent == agent).\n        buyer_collection_store.collections = ['1234', '56433']\n        buyer_collection_store_key = buyer_collection_store.put()\n        object_log = ObjectLog(parent=buyer_collection_store_key, agent=user_key, action='update', state='none', log=buyer_collection_store)\n        object_log.put()\n        # izaziva se update AggregateBuyerCollectionCatalog preko task queue\n    \n    # Brise store iz korisnikove liste\n    @ndb.transactional\n    def delete():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection_store.parent == agent).\n        object_log = ObjectLog(parent=buyer_collection_store_key, agent=user_key, action='delete', state='none')\n        object_log.put()\n        buyer_collection_store_key.delete()\n        # izaziva se update AggregateBuyerCollectionCatalog preko task queue\n        # ndb.delete_multi(AggregateBuyerCollectionCatalog.query(AggregateBuyerCollectionCatalog.store == buyer_collection_store.store, ancestor=user_key))\n\n# done! contention se moze zaobici ako write-ovi na ove entitete budu explicitno izolovani preko task queue\nclass AggregateBuyerCollectionCatalog(ndb.Model):\n    \n    # ancestor User\n    # not logged\n    # task queue radi agregaciju prilikom nekih promena na store-u\n    # mogao bi da se uvede index na collections radi filtera: AggregateBuyerCollectionCatalog.collections = 'collection', \n    # ovo moze biti dobra situacija za upotrebu MapReduce ??\n    # composite index: ancestor:yes - catalog_published_date:desc\n    store = ndb.KeyProperty('1', kind=Store, required=True)\n    collections = ndb.KeyProperty('2', kind=BuyerCollection, repeated=True, indexed=False)# soft limit 500x\n    catalog = ndb.KeyProperty('3', kind=Catalog, required=True, indexed=False)\n    catalog_cover = blobstore.BlobKeyProperty('4', required=True, indexed=False)# blob ce se implementirati na GCS\n    catalog_published_date = ndb.DateTimeProperty('5', required=True)\n\n################################################################################\n# USER REQUEST - 2\n################################################################################\n\n# done!\nclass FeedbackRequest(ndb.Model):\n    \n    # ancestor User\n    # ako hocemo da dozvolimo sva sortiranja, i dodatni filter po state-u uz sortiranje, onda nam trebaju slecedi indexi\n    # composite index:\n    # ancestor:yes - updated:desc; ancestor:yes - created:desc;\n    # ancestor:yes - state,updated:desc; ancestor:yes - state,created:desc\n    reference = ndb.StringProperty('1', required=True, indexed=False)\n    state = ndb.IntegerProperty('2', required=True)\n    updated = ndb.DateTimeProperty('3', auto_now=True, required=True)\n    created = ndb.DateTimeProperty('4', auto_now_add=True, required=True)\n    \n    # primer helper funkcije u slucajevima gde se ne koristi ancestor mehanizam za pristup relacijama\n    @property\n    def logs(self):\n      return ObjectLog.query(ancestor = self.key())\n    \n    _KIND = 8\n    \n    OBJECT_DEFAULT_STATE = 'new'\n    \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state\n        # ne znam da li je predvidjeno ovde da moze biti vise tranzicija/akcija koje vode do istog state-a,\n        # sto ce biti slucaj sa verovatno mnogim modelima.\n        # broj 0 je rezervisan za state none (Stateless Models) i ne koristi se za definiciju validnih state-ova\n        'new' : (1, ),\n        'reviewing' : (2, ),\n        'duplicate' : (3, ),\n        'accepted' : (4, ),\n        'dismissed' : (5, ),\n    }\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'review' : 3,\n       'close' : 4,\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'review' : {\n            'from' : ('new',),\n            'to' : ('reviewing',),\n         },\n        'close' : {\n           'from' : ('reviewing', ),\n           'to'   : ('duplicate', 'accepted', 'dismissed',),\n        },\n    }\n    \n    # Ova akcija sluzi za slanje feedback-a miraclestyle timu od strane krajnjih korisnika.\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        feedback_request = FeedbackRequest(parent=user_key, reference='https://www,miraclestyle.com/...', state='new')\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=user_key, action='create', state=feedback_request.state, message='poruka od agenta - obavezno polje!')\n        object_log.put()\n    \n    # Ova akcija sluzi za insert ObjectLog-a koji je descendant FeedbackRequest entitetu.\n    # Insertom ObjectLog-a dozvoljeno je unosenje poruke (i privatnog komentara), sto je i smisao ove akcije.\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'update-FeedbackRequest'. / ? # ovu akciju moze izvrsiti samo entity owner (feedback_request.parent == agent) ili agent koji ima globalnu dozvolu 'update-FeedbackRequest'.\n        # Radi se update FeedbackRequest-a bez izmena na bilo koji prop. (u cilju izazivanja promene na FeedbackRequest.updated prop.)\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=agent_key, action='update', state=feedback_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje FeedbackRequest entiteta u 'reviewing'.\n    @ndb.transactional\n    def review():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'review-FeedbackRequest'.\n        # akcija se moze pozvati samo ako je feedback_request.state == 'new'.\n        feedback_request.state = 'reviewing'\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=agent_key, action='review', state=feedback_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje FeedbackRequest entiteta u 'duplicate', 'accepted', ili 'dismissed'.\n    @ndb.transactional\n    def close():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'close-FeedbackRequest'.\n        # akcija se moze pozvati samo ako je feedback_request.state == 'reviewing'.\n        feedback_request.state = 'duplicate' | 'accepted' | 'dismissed'\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=agent_key, action='close', state=feedback_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n\n# done!\nclass SupportRequest(ndb.Model):\n    \n    # ancestor User\n    # ako uopste bude vidljivo useru onda mozemo razmatrati indexing\n    # ako hocemo da dozvolimo sva sortiranja, i dodatni filter po state-u uz sortiranje, onda nam trebaju slecedi indexi\n    # composite index:\n    # ancestor:yes - updated:desc; ancestor:yes - created:desc;\n    # ancestor:yes - state,updated:desc; ancestor:yes - state,created:desc\n    reference = ndb.StringProperty('1', required=True, indexed=False)\n    state = ndb.IntegerProperty('2', required=True)\n    updated = ndb.DateTimeProperty('3', auto_now=True, required=True)\n    created = ndb.DateTimeProperty('4', auto_now_add=True, required=True)\n    \n    _KIND = 9\n    \n    OBJECT_DEFAULT_STATE = 'new'\n    \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state\n        # ne znam da li je predvidjeno ovde da moze biti vise tranzicija/akcija koje vode do istog state-a,\n        # sto ce biti slucaj sa verovatno mnogim modelima.\n        # broj 0 je rezervisan za state none (Stateless Models) i ne koristi se za definiciju validnih state-ova\n        'new' : (1, ),\n        'opened' : (2, ),\n        'awaiting_closure' : (3, ),\n        'closed' : (4, ),\n    }\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'open' : 3,\n       'propose_close' : 4,\n       'close' : 5,\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'open' : {\n            'from' : ('new',),\n            'to' : ('opened',),\n         },\n        'propose_close' : {\n           'from' : ('opened', ),\n           'to'   : ('awaiting_closure',),\n        },\n        'close' : {\n           'from' : ('opened', 'awaiting_closure',),\n           'to'   : ('closed',),\n        },\n    }\n    \n    # Ova akcija krajnjem korisniku sluzi za pravljenje zahteva za pomoc (ticket-a) od miraclestyle tima.\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        support_request = SupportRequest(parent=user_key, reference='https://www,miraclestyle.com/...', state='new')\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=user_key, action='create', state=support_request.state, message='poruka od agenta - obavezno polje!')\n        object_log.put()\n    \n    # Ova akcija sluzi za insert ObjectLog-a koji je descendant SupportRequest entitetu.\n    # Insertom ObjectLog-a dozvoljeno je unosenje poruke (i privatnog komentara), sto je i smisao ove akcije.\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (support_request.parent == agent) ili agent koji ima globalnu dozvolu 'update-SupportRequest'\n        # Radi se update SupportRequest-a bez izmena na bilo koji prop. (u cilju izazivanja promene na SupportRequest.updated prop.)\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='update', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje SupportRequest entiteta u 'opened'.\n    @ndb.transactional\n    def open():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'open-SupportRequest'.\n        # akcija se moze pozvati samo ako je support_request.state == 'new'.\n        support_request.state = 'opened'\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='open', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje SupportRequest entiteta u 'awaiting_closure'.\n    @ndb.transactional\n    def propose_close():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'propose_close-SupportRequest'.\n        # akcija se moze pozvati samo ako je support_request.state == 'opened'.\n        support_request.state = 'awaiting_closure'\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='propose_close', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom agent menja stanje SupportRequest entiteta u 'closed'.\n    @ndb.transactional\n    def close():\n        # ovu akciju moze izvrsiti samo entity owner (support_request.parent == agent) ili agent koji ima globalnu dozvolu 'close-SupportRequest' (sto ce verovatno imati sistemski account koji ce preko cron-a izvrsiti akciju).\n        # akcija se moze pozvati samo ako je support_request.state == 'opened' ili support_request.state == 'awaiting_closure'.\n        support_request.state = 'closed'\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='close', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n\n################################################################################\n# DOMAIN - \n################################################################################\n\n# done!\nclass Domain(ndb.Expando):\n    \n    # root\n    # composite index: ancestor:no - state,name\n    name = ndb.StringProperty('1', required=True)\n    primary_contact = ndb.KeyProperty('2', kind=User, required=True, indexed=False)\n    state = ndb.IntegerProperty('3', required=True)\n    _default_indexed = False\n    pass\n    #Expando\n    \n    _KIND = 3\n    \n    OBJECT_DEFAULT_STATE = 'active'\n    \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state\n        # Ne znam da li je predvidjeno ovde da moze biti vise tranzicija/akcija koje vode do istog state-a,\n        # sto ce biti slucaj sa verovatno mnogim modelima.\n        # broj 0 je rezervisan za none (Stateless Models) i ne koristi se za definiciju validnih state-ova\n        'active' : (1, ),\n        'suspended' : (2, ),\n        'terminated' : (3, ),\n    }\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'suspend' : 3,\n       'terminate' : 4,\n       'activate_suspended' : 5,\n       'activate_terminated' : 6,\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'activate_suspended' : {\n            'from' : ('suspended',),\n            'to' : ('active',),\n         },\n         'activate_terminated' : {\n            'from' : ('terminated',),\n            'to' : ('active',),\n         },\n        'suspend' : {\n           'from' : ('active', ),\n           'to'   : ('suspended',),\n        },\n        'terminate' : {\n           'from' : ('active', 'suspended'),\n           'to'   : ('terminated',),\n        },\n    }\n    \n    # *** mozda treba zameniti dozvole za upravljanje domenom sa jednom dozvolom 'manage-Domain' ili tome slicno!\n    \n    # Ova akcija kreira novu domenu.\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        domain = Domain(name='deskriptivno ime po zelji kreatora', primary_contact=user_key, state='active')\n        domain_key = domain.put()\n        object_log = ObjectLog(parent=domain_key, agent=user_key, action='create', state=domain.state, log=domain)\n        object_log.put()\n        role = Role(parent=domain_key, name='Domain Admins', permissions=['*',], readonly=True)\n        role_key = role.put()\n        role_user = RoleUser(parent=role_key, user=user_key, state='accepted')\n        role_user_key = role_user.put()\n        #object_log = ObjectLog(parent=role_user_key, agent=user_key, action='accept', state=role_user.state, log=role_user)\n        #object_log.put()\n        sub_role = Role(namespace=domain_key, parent=role_user.user, id=str(role_key.id()), name='Domain Admins', permissions=['*',], readonly=True)\n        sub_role.put()\n    \n    # Ova akcija azurira postojecu domenu.\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo agent koji ima domain-specific dozvolu 'update-Domain'. ***\n        # akcija se moze pozvati samo ako je domain.state == 'active'.\n        domain.name = 'promenjeno ime od strane administratora domene'\n        domain.primary_contact = agent_key # u ovaj prop. se moze upisati samo key user-a koji ima domain-specific dozvolu 'manage_security-Domain'. ? provericemo kako je to na google apps\n        domain_key = domain.put()\n        object_log = ObjectLog(parent=domain_key, agent=agent_key, action='update', state=domain.state, log=domain)\n        object_log.put()\n    \n    # Ova akcija suspenduje aktivnu domenu. Ovde cemo dalje opisati posledice suspenzije\n    @ndb.transactional\n    def suspend():\n        # ovu akciju moze izvrsiti samo agent koji ima domain-specific dozvolu 'suspend-Domain'. ***\n        # akcija se moze pozvati samo ako je domain.state == 'active'.\n        domain.state = 'suspended'\n        domain_key = domain.put()\n        object_log = ObjectLog(parent=domain_key, agent=agent_key, action='suspend', state=domain.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n    \n    # Ova akcija terminira aktivnu ili suspendovanu domenu. Ovde cemo dalje opisati posledice terminacije\n    @ndb.transactional\n    def terminate():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'terminate-Domain'.\n        # akcija se moze pozvati samo ako je domain.state == 'active' ili domain.state == 'suspended'.\n        # ova akcija treba biti mozda drugacije protected od ostalih akcija, to se moze resiti na dva nacina:\n        # prvi nacin je da se domain administrativnim userima zabrani mogucnost dodavanja dozvole 'terminate-Domain' u listi dozvola na domain-specific Rolama\n        # drugi nacin je da se ova metoda drugacije evaluira, tako da ignorise proveru domain-specific Rola\n        domain.state = 'terminated'\n        domain_key = domain.put()\n        object_log = ObjectLog(parent=domain_key, agent=agent_key, action='terminate', state=domain.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n    \n    # Ova akcija aktivira suspendovanu domenu. Ovde cemo dalje opisati posledice aktivacije\n    @ndb.transactional\n    def activate_suspended():\n        # ovu akciju moze izvrsiti samo agent koji ima domain-specific dozvolu 'activate_suspended-Domain'. ***\n        # akcija se moze pozvati samo ako je domain.state == 'suspended'.\n        domain.state = 'active'\n        domain_key = domain.put()\n        object_log = ObjectLog(parent=domain_key, agent=agent_key, action='activate_suspended', state=domain.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n    \n    # Ova akcija aktivira terminiranu domenu. Ovde cemo dalje opisati posledice aktivacije\n    @ndb.transactional\n    def activate_terminated():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'activate_terminated-Domain'.\n        # akcija se moze pozvati samo ako je domain.state == 'terminated'.\n        # ova akcija treba biti mozda drugacije protected od ostalih akcija, to se moze resiti na dva nacina:\n        # prvi nacin je da se domain administrativnim userima zabrani mogucnost dodavanja dozvole 'activate_terminated-Domain' u listi dozvola na domain-specific Rolama\n        # drugi nacin je da se ova metoda drugacije evaluira, tako da ignorise proveru domain-specific Rola\n        domain.state = 'active'\n        domain_key = domain.put()\n        object_log = ObjectLog(parent=domain_key, agent=agent_key, action='activate_terminated', state=domain.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n\n# done!\nclass Role(ndb.Model):\n    \n    # root (namespace Domain/'MIRACLESTYLE')\n    # Role permissions affect Domain and it's related entities, with exception to Roles in 'MIRACLESTYLE' namespace.\n    # Roles in 'MIRACLESTYLE' namespace globally affect Miraclestyle Application and all of it's related entities.\n    # ancestor User (for caching/optimization purposes) - Role(namespace=domain_key, parent=user_key, id=str(role_key.id()), ....)\n    # TREBA TESTIRATI DA LI RADE QUERY: Role.query(namespace=..., ancestor=..., id=....)\n    # mozda bude trebalo jos indexa u zavistnosti od potreba u UIUX\n    # composite index: ancestor:yes - name\n    name = ndb.StringProperty('1', required=True)\n    permissions = ndb.StringProperty('2', repeated=True, indexed=False)# soft limit 1000x - action-Model - create-Store\n    readonly = ndb.BooleanProperty('3', default=True, indexed=False)\n    \n    _KIND = 6\n    \n    OBJECT_DEFAULT_STATE = 'none'\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'delete' : 3,\n    }\n    \n    # Pravi novu rolu domene, ili globalnu rolu\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo agent koji ima domain-specific dozvolu 'create-Role'. \n        # u slucaju kreiranja Role u 'MIRACLESTYLE' domeni, agent mora biti Application Admin (users.is_current_user_admin()).\n        # akcija se moze pozvati samo ako je domain.state == 'active'.\n        # domena 'MIRACLESTYLE' je uvek evaluated 'active'\n        role = Role(namespace=domain_key, name='Store Managers', permissions=['create_store', 'update_store',], readonly=False) # readonly je uvek False za user generated Roles\n        role_key = role.put()\n        object_log = ObjectLog(parent=role_key, agent=agent_key, action='create', state='none', log=role)\n        object_log.put()\n    \n    # Azurira postojecu rolu domene, ili globalnu rolu\n    @ndb.transactional\n    def update():\n        # (u slucaju da agent treba azurirati globalne Role imacemo problem posto bi globalna dozvola 'update-Role'\n        # po trenutnom konceptu znacila da user sa ovom dozvolom moze u svakoj domeni raditi 'update-Role').\n        # ovu akciju moze izvrsiti samo agent koji ima domain-specific dozvolu 'update-Role'.\n        # akcija se moze pozvati samo ako je domain.state == 'active'.\n        role.name = 'New Store Managers'\n        role.permissions = ['create_store',]\n        role_key = role.put()\n        object_log = ObjectLog(parent=role_key, agent=agent_key, action='update', state='none', log=role)\n        object_log.put()\n        role_users = RoleUser.query(ancestor=role_key).fetch(projection=[RoleUser.user,])\n        # ovo uraditi sa taskletima za async operacije\n        for role_user in role_users:\n            key = ndb.Key(namespace=domain_key, parent=role_user, str(role_key.id()))\n            sub_role = key.get()\n            sub_role.name = role.name\n            sub_role.permissions = role.permissions\n            sub_role.put()\n    \n    # Brise postojecu rolu domene, ili globalnu rolu.\n    @ndb.transactional\n    def delete():\n        # (u slucaju da agent treba brisati globalne Role imacemo problem posto bi globalna dozvola 'delete-Role'\n        # po trenutnom konceptu znacila da user sa ovom dozvolom moze u svakoj domeni raditi 'delete-Role').\n        # ovu akciju moze izvrsiti samo agent koji ima domain-specific dozvolu 'delete-Role'.\n        # akcija se moze pozvati samo ako je domain.state == 'active'.\n        object_log = ObjectLog(parent=role_key, agent=agent_key, action='delete', state='none')\n        object_log.put()\n        role_users = RoleUser.query(ancestor=role_key).fetch(projection=[RoleUser.user,])\n        roles = []\n        for role_user in role_users:\n            key = ndb.Key(namespace=domain_key, parent=role_user, str(role_key.id()))\n            roles.append(key)\n        ndb.delete_multi(roles)\n        ndb.delete_multi(role_users)\n        role_key.delete()\n\n# done!\nclass RoleUser(ndb.Model):\n    \n    # ancestor Role\n    # id = str(user_key.id())\n    # mozda bude trebalo jos indexa u zavistnosti od potreba u UIUX\n    # composite index: ancestor:yes - user\n    user = ndb.KeyProperty('1', kind=User, required=True)\n    state = ndb.IntegerProperty('2', required=True)# invited/accepted\n    \n    _KIND = 7\n    \n    OBJECT_DEFAULT_STATE = 'none'\n    \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state\n        # Ne znam da li je predvidjeno ovde da moze biti vise tranzicija/akcija koje vode do istog state-a,\n        # sto ce biti slucaj sa verovatno mnogim modelima.\n        # broj 0 je rezervisan za none (Stateless Models) i ne koristi se za definiciju validnih state-ova\n        'invited' : (1, ),\n        'accepted' : (2, ),\n    }\n    \n    OBJECT_ACTIONS = {\n       'invite' : 1,\n       'remove' : 2,\n       'accept' : 3,\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'accept' : {\n            'from' : ('invited',),\n            'to' : ('accepted',),\n        },\n    }\n    \n    # Poziva novog usera u rolu domene, ili globalnu rolu\n    @ndb.transactional\n    def invite():\n        # (u slucaju da se user treba invite na globalnu Rolu imacemo problem posto bi globalna dozvola 'invite-RoleUser'\n        # po trenutnom konceptu znacila da user sa ovom dozvolom moze u svakoj domeni raditi 'invite').\n        # ovu akciju moze izvrsiti samo agent koji ima domain-specific dozvolu 'invite-RoleUser'.\n        # akcija se moze pozvati samo ako je domain.state == 'active'.\n        role_user = RoleUser(parent=role_key, user='123673472829', state='invited')\n        role_user_key = role_user.put()\n        object_log = ObjectLog(parent=role_user_key, agent=agent_key, action='invite', state=role_user.state, log=role_user)\n        object_log.put()\n        # salje se notifikacija korisniku da je dobio poziv za dodavanje u Rolu.\n    \n    # Uklanja postojeceg usera iz role domene, ili globalne role.\n    @ndb.transactional\n    def remove():\n        # (u slucaju da se user treba remove sa globalne Role imacemo problem posto bi globalna dozvola 'remove-RoleUser'\n        # po trenutnom konceptu znacila da user sa ovom dozvolom moze u svakoj domeni raditi 'remove').\n        # ovu akciju moze izvrsiti samo agent koji ima domain-specific dozvolu 'remove-RoleUser', ili agent koji je referenciran u entitetu (role_user.user == agent).\n        # akcija se moze pozvati samo ako je domain.state == 'active'.\n        object_log = ObjectLog(parent=role_user_key, agent=agent_key, action='remove', state=role_user.state)\n        object_log.put()\n        role_user_key.delete()\n        key = ndb.Key(namespace=domain_key, parent=role_user.user, str(role_key.id()))\n        # ovaj delete ce fail ukoliko nije napravljen entitet sa tim kljucem, napr: ako je role_user.state == 'invited'\n        key.delete()\n    \n    # Prihvata poziv novog usera u rolu (lokalne ili globalne - \"MIRACLESTYLE\") domene\n    @ndb.transactional\n    def accept():\n        # ovu akciju moze izvrsiti samo agent koji je referenciran u entitetu (role_user.user == agent).\n        # akcija se moze pozvati samo ako je domain.state == 'active'.\n        role_user.state = 'accepted'\n        role_user_key = role_user.put()\n        object_log = ObjectLog(parent=role_user_key, agent=agent_key, action='accept', role_user.state)\n        object_log.put()\n        sub_role = Role(namespace=domain_key, parent=role_user.user, id=str(role_key.id()), name='~', permissions=['~',], readonly='True/False')\n        sub_role.put()\n\n# future implementation - prototype!\nclass Rule(ndb.Model):\n    \n    # root\n    name = ndb.StringProperty('1', required=True)\n    model_kind = ndb.StringProperty('2', required=True)\n    actions = ndb.StringProperty('3', repeated=True)\n    fields = ndb.LocalStructuredProperty(Field, '4', repeated=True)\n    condition = ndb.TextProperty('5')\n    roles = ndb.KeyProperty('6', kind=Role, repeated=True)\n\n# future implementation - prototype!\nclass Field(ndb.Model):\n    \n    # LocalStructuredProperty model\n    name = ndb.StringProperty('1', required=True, indexed=False)\n    writable = ndb.BooleanProperty('2', default=True, indexed=False)\n    visible = ndb.BooleanProperty('3', default=True, indexed=False)"],[0,"\n\n\n\n\n\n\n\n"]],"start1":10333,"start2":10333,"length1":17,"length2":34320}]],"length":44656,"saved":false}
{"ts":1378921597485,"patch":[[{"diffs":[[0,"False)\n\n"],[-1,"\n"],[1,"# done!\nclass Store(ndb.Expando):\n    \n    # root (namespace Domain)\n    # composite index: ancestor:no - state,name\n    name = ndb.StringProperty('1', required=True)\n    logo = blobstore.BlobKeyProperty('2', required=True)# blob ce se implementirati na GCS\n    state = ndb.IntegerProperty('3', required=True)\n    _default_indexed = False\n    pass\n    #Expando\n    #\n    # Company\n    # company_name = ndb.StringProperty('4', required=True)\n    # company_country = ndb.KeyProperty('5', kind=Country, required=True)\n    # company_region = ndb.KeyProperty('6', kind=CountrySubdivision, required=True)# ako je potreban string val onda se ovo preskace \n    # company_region = ndb.StringProperty('6', required=True)# ako je potreban key val onda se ovo preskace\n    # company_city = ndb.StringProperty('7', required=True)\n    # company_postal_code = ndb.StringProperty('8', required=True)\n    # company_street_address = ndb.StringProperty('9', required=True)\n    # company_street_address2 = ndb.StringProperty('10')\n    # company_email = ndb.StringProperty('11')\n    # company_telephone = ndb.StringProperty('12')\n    #\n    # Payment\n    # currency = ndb.KeyProperty('13', kind=Currency, required=True)\n    # tax_buyer_on ?\n    # paypal_email = ndb.StringProperty('14')\n    # paypal_shipping ?\n    #\n    # Analytics \n    # tracking_id = ndb.StringProperty('15')\n    #\n    # Feedback\n    # feedbacks = ndb.LocalStructuredProperty(StoreFeedback, '16', repeated=True)# soft limit 120x\n\n# done!\nclass StoreFeedback(ndb.Model):\n    \n    # LocalStructuredProperty model\n    # ovaj model dozvoljava da se radi feedback trending per month per year\n    # mozda bi se mogla povecati granulacija per week, tako da imamo oko 52 instance per year, ali mislim da je to nepotrebno!\n    # ovde treba voditi racuna u scenarijima kao sto je napr. promena feedback-a iz negative u positive state,\n    # tako da se za taj record uradi negative_feedback_count - 1 i positive_feedback_count + 1\n    month = ndb.IntegerProperty('1', required=True, indexed=False)\n    year = ndb.IntegerProperty('2', required=True, indexed=False)\n    positive_feedback_count = ndb.IntegerProperty('3', required=True, indexed=False)\n    negative_feedback_count = ndb.IntegerProperty('4', required=True, indexed=False)\n    neutral_feedback_count = ndb.IntegerProperty('5', required=True, indexed=False)\n\n# done!\nclass StoreContent(ndb.Model):\n    \n    # ancestor Store (Catalog - for caching)\n    # composite index: ancestor:yes - sequence\n    title = ndb.StringProperty('1', required=True)\n    body = ndb.TextProperty('2', required=True)\n    sequence = ndb.IntegerProperty('3', required=True)\n\n# done!\nclass StoreShippingExclusion(Location):\n    \n    # ancestor Store (Catalog - for caching)\n    # ovde bi se indexi mozda mogli dobro iskoristiti?\n\n# done!\nclass Tax(ndb.Expando):\n    \n    # root (namespace Domain)\n    # composite index: ancestor:no - active,sequence\n    name = ndb.StringProperty('1', required=True)\n    sequence = ndb.IntegerProperty('2', required=True)\n    amount = ndb.StringProperty('3', required=True, indexed=False)# prekompajlirane vrednosti iz UI, napr: 17.00[%] ili 10.00[c] gde je [c] = currency\n    location_exclusion = ndb.BooleanProperty('4', default=False, indexed=False)# applies to all locations except/applies to all locations listed below\n    active = ndb.BooleanProperty('5', default=True)\n    _default_indexed = False\n    pass\n    # Expando\n    # locations = ndb.LocalStructuredProperty(Location, '6', repeated=True)# soft limit 300x\n    # product_categories = ndb.KeyProperty('7', kind=ProductCategory, repeated=True)# soft limit 100x\n    # carriers = ndb.KeyProperty('8', kind=Carrier, repeated=True)# soft limit 100x\n\n# done!\nclass Carrier(ndb.Model):\n    \n    # root (namespace Domain)\n    # http://bazaar.launchpad.net/~openerp/openobject-addons/saas-1/view/head:/delivery/delivery.py#L27\n    # http://hg.tryton.org/modules/carrier/file/tip/carrier.py#l10\n    # composite index: ancestor:no - active,name\n    name = ndb.StringProperty('1', required=True)\n    active = ndb.BooleanProperty('2', default=True)\n\n# done!\nclass CarrierLine(ndb.Expando):\n    \n    # ancestor Carrier\n    # http://bazaar.launchpad.net/~openerp/openobject-addons/saas-1/view/head:/delivery/delivery.py#L170\n    # composite index: ancestor:yes - sequence; ancestor:yes - active,sequence\n    name = ndb.StringProperty('1', required=True)\n    sequence = ndb.IntegerProperty('2', required=True)\n    location_exclusion = ndb.BooleanProperty('3', default=False, indexed=False)\n    active = ndb.BooleanProperty('4', default=True)\n    _default_indexed = False\n    pass\n    # Expando\n    # locations = ndb.LocalStructuredProperty(Location, '5', repeated=True)# soft limit 300x\n    # rules = ndb.LocalStructuredProperty(CarrierLineRule, '6', repeated=True)# soft limit 300x\n\n# done!\nclass CarrierLineRule(ndb.Model):\n    \n    # LocalStructuredProperty model\n    # http://bazaar.launchpad.net/~openerp/openobject-addons/saas-1/view/head:/delivery/delivery.py#L226\n    # ovde se cuvaju dve vrednosti koje su obicno struktuirane kao formule, ovo je mnogo fleksibilnije nego hardcoded struktura informacija koje se cuva kao sto je bio prethodni slucaj\n    condition = ndb.StringProperty('1', required=True, indexed=False)# prekompajlirane vrednosti iz UI, napr: True ili weight[kg] >= 5 ili volume[m3] = 0.002\n    price = ndb.StringProperty('2', required=True, indexed=False)# prekompajlirane vrednosti iz UI, napr: amount = 35.99 ili amount = weight[kg]*0.28\n    # weight - kg; volume - m3; ili sta vec odlucimo, samo je bitno da se podudara sa measurementsima na ProductTemplate/ProductInstance\n\n# done!\nclass Catalog(ndb.Expando):\n    \n    # root (namespace Domain)\n    # https://support.google.com/merchants/answer/188494?hl=en&hlrm=en#other\n    # composite index: ???\n    store = ndb.KeyProperty('1', kind=Store, required=True)\n    name = ndb.StringProperty('2', required=True)\n    publish = ndb.DateTimeProperty('3', required=True)# today\n    discontinue = ndb.DateTimeProperty('4', required=True)# +30 days\n    cover = blobstore.BlobKeyProperty('5', required=True)# blob ce se implementirati na GCS\n    cost = DecimalProperty('6', required=True, indexed=False)\n    state = ndb.IntegerProperty('7', required=True)\n    _default_indexed = False\n    pass\n    # Expando\n    # Search improvements\n    # product count per product category\n    # rank coefficient based on store feedback\n\n# done!\nclass CatalogImage(Image):\n    \n    # ancestor Catalog\n    # composite index: ancestor:yes - sequence\n\n# done!\nclass CatalogPricetag(ndb.Model):\n    \n    # ancestor Catalog\n    product_template = ndb.KeyProperty('1', kind=ProductTemplate, required=True, indexed=False)\n    container_image = blobstore.BlobKeyProperty('2', required=True, indexed=False)# blob ce se implementirati na GCS\n    source_width = ndb.FloatProperty('3', required=True, indexed=False)\n    source_height = ndb.FloatProperty('4', required=True, indexed=False)\n    source_position_top = ndb.FloatProperty('5', required=True, indexed=False)\n    source_position_left = ndb.FloatProperty('6', required=True, indexed=False)\n    value = ndb.StringProperty('7', required=True, indexed=False)# $ 19.99 - ovo se handla unutar transakcije kada se radi update na unit_price od ProductTemplate ili ProductInstance\n\n# done!\nclass ProductTemplate(ndb.Expando):\n    \n    # ancestor Catalog (future - root / namespace Domain)\n    # composite index: ancestor:yes - name\n    product_category = ndb.KeyProperty('1', kind=ProductCategory, required=True, indexed=False)\n    name = ndb.StringProperty('2', required=True)\n    description = ndb.TextProperty('3', required=True)# soft limit 64kb\n    product_uom = ndb.KeyProperty('4', kind=ProductUOM, required=True, indexed=False)\n    unit_price = DecimalProperty('5', required=True)\n    state = ndb.IntegerProperty('6', required=True, indexed=False)\n    # states: - ovo cemo pojasniti\n    # 'in stock'\n    # 'available for order'\n    # 'out of stock'\n    # 'preorder'\n    # 'auto manage inventory - available for order' (poduct is 'available for order' when inventory balance is <= 0)\n    # 'auto manage inventory - out of stock' (poduct is 'out of stock' when inventory balance is <= 0)\n    # https://support.google.com/merchants/answer/188494?hl=en&ref_topic=2473824\n    _default_indexed = False\n    pass\n    # Expando\n    # mozda treba uvesti customer lead time??\n    # product_template_variants = ndb.KeyProperty('7', kind=ProductVariant, repeated=True)# soft limit 100x\n    # product_template_contents = ndb.KeyProperty('8', kind=ProductContent, repeated=True)# soft limit 100x\n    # product_template_images = ndb.LocalStructuredProperty(Image, '9', repeated=True)# soft limit 100x\n    # weight = ndb.StringProperty('10')# prekompajlirana vrednost, napr: 0.2[kg] - gde je [kg] jediniva mere, ili sta vec odlucimo\n    # volume = ndb.StringProperty('11')# prekompajlirana vrednost, napr: 0.03[m3] - gde je [m3] jediniva mere, ili sta vec odlucimo\n\n# done!\nclass ProductInstance(ndb.Expando):\n    \n    # ancestor ProductTemplate\n    #variant_signature se gradi na osnovu ProductVariant entiteta vezanih za ProductTemplate-a (od aktuelne ProductInstance) preko ProductTemplateVariant \n    #key name ce se graditi tako sto se uradi MD5 na variant_signature\n    #query ce se graditi tako sto se prvo izgradi variant_signature vrednost na osnovu odabira od strane krajnjeg korisnika a potom se ta vrednost hesira u MD5 i koristi kao key identifier\n    #mana ove metode je ta sto se uvek mora izgraditi kompletan variant_signature, tj moraju se sve varijacije odabrati (svaka varianta mora biti mandatory_variant_type)\n    #default vrednost code ce se graditi na osnovu sledecih informacija: ancestorkey-n, gde je n incremental integer koji se dodeljuje instanci prilikom njenog kreiranja\n    #ukoliko user ne odabere multivariant opciju onda se za ProductTemplate generise samo jedna ProductInstance i njen key se gradi automatski.\n    # composite index: ancestor:yes - code\n    code = ndb.StringProperty('1', required=True)\n    state = ndb.IntegerProperty('2', required=True, indexed=False)# ukljuciti index ako bude trebao za projection query\n    # states: - ovo cemo pojasniti\n    # 'in stock'\n    # 'available for order'\n    # 'out of stock'\n    # 'preorder'\n    # 'auto manage inventory - available for order' (poduct is 'available for order' when inventory balance is <= 0)\n    # 'auto manage inventory - out of stock' (poduct is 'out of stock' when inventory balance is <= 0)\n    # https://support.google.com/merchants/answer/188494?hl=en&ref_topic=2473824\n    _default_indexed = False\n    pass\n    # Expando\n    # description = ndb.TextProperty('3', required=True)# soft limit 64kb\n    # unit_price = DecimalProperty('4', required=True)\n    # product_instance_contents = ndb.KeyProperty('5', kind=ProductContent, repeated=True)# soft limit 100x\n    # product_instance_images = ndb.LocalStructuredProperty(Image, '6', repeated=True)# soft limit 100x\n    # low_stock_quantity = DecimalProperty('7', default=0.00)# notify store manager when qty drops below X quantity\n    # weight = ndb.StringProperty('8')# prekompajlirana vrednost, napr: 0.2[kg] - gde je [kg] jediniva mere, ili sta vec odlucimo\n    # volume = ndb.StringProperty('9')# prekompajlirana vrednost, napr: 0.03[m3] - gde je [m3] jediniva mere, ili sta vec odlucimo\n    # variant_signature = ndb.TextProperty('10', required=True)# soft limit 64kb - ova vrednost kao i vrednosti koje kupac manuelno upise kao opcije variante se prepisuju u order line description prilikom Add to Cart\n\n# done! contention se moze zaobici ako write-ovi na ove entitete budu explicitno izolovani preko task queue\nclass ProductInventoryLog(ndb.Model):\n    \n    # ancestor ProductInstance\n    # not logged\n    # composite index: ancestor:yes - logged:desc\n    logged = ndb.DateTimeProperty('1', auto_now_add=True, required=True)\n    reference = ndb.KeyProperty('2',required=True)# idempotency je moguc ako se pre inserta proverava da li je record sa tim reference-om upisan \n    quantity = DecimalProperty('3', required=True, indexed=False)# ukljuciti index ako bude trebao za projection query\n    balance = DecimalProperty('4', required=True, indexed=False)# ukljuciti index ako bude trebao za projection query\n\n# done!\nclass ProductInventoryAdjustment(ndb.Model):\n    \n    # ancestor ProductInstance\n    # not logged\n    adjusted = ndb.DateTimeProperty('1', auto_now_add=True, required=True, indexed=False)\n    agent = ndb.KeyProperty('2', kind=User, required=True, indexed=False)\n    quantity = DecimalProperty('3', required=True, indexed=False, indexed=False)\n    comment = ndb.StringProperty('4', required=True, indexed=False)\n\n# done!\nclass ProductVariant(ndb.Model):\n    \n    # ancestor Catalog (future - root / namespace Domain)\n    # http://v6apps.openerp.com/addon/1809\n    # composite index: ancestor:yes - name\n    name = ndb.StringProperty('1', required=True)\n    description = ndb.TextProperty('2')# soft limit 64kb\n    options = ndb.StringProperty('3', repeated=True, indexed=False)# soft limit 1000x\n    allow_custom_value = ndb.BooleanProperty('4', default=False, indexed=False)# ovu vrednost buyer upisuje u definisano polje a ona se dalje prepisuje u order line description prilikom Add to Cart \n\n# done!\nclass ProductContent(ndb.Model):\n    \n    # ancestor Catalog (future - root / namespace Domain)\n    # composite index: ancestor:yes - title\n    title = ndb.StringProperty('1', required=True)\n    body = ndb.TextProperty('2', required=True)"],[0,"\n\n\n\n\n\n\n\n"]],"start1":44639,"start2":44639,"length1":17,"length2":13570}]],"length":58209,"saved":false}
{"ts":1378921649192,"patch":[[{"diffs":[[0,"d=True)\n\n\n\n\n"],[1,"################################################################################\n# TRADE - 11\n################################################################################\n\n# done!\nclass Order(ndb.Expando):\n    \n    # ancestor User (namespace Domain)\n    # http://hg.tryton.org/modules/sale/file/tip/sale.py#l28\n    # http://hg.tryton.org/modules/purchase/file/tip/purchase.py#l32\n    # http://doc.tryton.org/2.8/modules/sale/doc/index.html\n    # http://doc.tryton.org/2.8/modules/purchase/doc/index.html\n    # http://bazaar.launchpad.net/~openerp/openobject-addons/7.0/view/head:/sale/sale.py#L48\n    # buyer = ndb.KeyProperty('1', kind=User, required=True)\n    # composite index: \n    # ancestor:no - store,state,updated:desc; ancestor:no - store,state,order_date:desc\n    # ancestor:no - state,updated:desc; ancestor:no - state,order_date:desc\n    # ancestor:yes - state,updated:desc; ancestor:yes - state,order_date:desc\n    store = ndb.KeyProperty('1', kind=Store, required=True)\n    order_date = ndb.DateTimeProperty('2', auto_now_add=True, required=True)# updated on checkout\n    currency = ndb.LocalStructuredProperty(OrderCurrency, '3', required=True)\n    untaxed_amount = DecimalProperty('4', required=True, indexed=False)\n    tax_amount = DecimalProperty('5', required=True, indexed=False)\n    total_amount = DecimalProperty('6', required=True)\n    state = ndb.IntegerProperty('7', required=True) \n    updated = ndb.DateTimeProperty('8', auto_now=True, required=True)\n    _default_indexed = False\n    pass\n    # Expando\n    # company_address = ndb.LocalStructuredProperty(OrderAddress, '9', required=True)\n    # billing_address = ndb.LocalStructuredProperty(OrderAddress, '10', required=True)\n    # shipping_address = ndb.LocalStructuredProperty(OrderAddress, '11', required=True)\n    # reference = ndb.StringProperty('12', required=True)\n    # comment = ndb.TextProperty('13')# 64kb limit\n    # company_address_reference = ndb.KeyProperty('14', kind=Store, required=True)\n    # billing_address_reference = ndb.KeyProperty('15', kind=BuyerAddress, required=True)\n    # shipping_address_reference = ndb.KeyProperty('16', kind=BuyerAddress, required=True)\n    # carrier_reference = ndb.KeyProperty('17', kind=StoreCarrier, required=True)\n    # feedback = ndb.IntegerProperty('18', required=True)\n    # store_name = ndb.StringProperty('19', required=True, indexed=True)# testirati da li ovo indexiranje radi, tj overrid-a _default_indexed = False\n    # store_logo = blobstore.BlobKeyProperty('20', required=True, indexed=True)# testirati da li ovo indexiranje radi, tj overrid-a _default_indexed = False\n\n# done!\nclass OrderFeedback(ndb.Model):\n    \n    # ancestor Order\n    state = ndb.IntegerProperty('1', required=True, indexed=False)\n\n# done!\nclass BillingOrder(ndb.Expando):\n    \n    # root (namespace Domain)\n    # http://hg.tryton.org/modules/sale/file/tip/sale.py#l28\n    # http://hg.tryton.org/modules/purchase/file/tip/purchase.py#l32\n    # http://doc.tryton.org/2.8/modules/sale/doc/index.html\n    # http://doc.tryton.org/2.8/modules/purchase/doc/index.html\n    # http://bazaar.launchpad.net/~openerp/openobject-addons/7.0/view/head:/sale/sale.py#L48\n    order_date = ndb.DateTimeProperty('1', auto_now_add=True, required=True, indexed=False)# updated on checkout\n    currency = ndb.LocalStructuredProperty(OrderCurrency, '2', required=True)\n    untaxed_amount = DecimalProperty('3', required=True, indexed=False)\n    tax_amount = DecimalProperty('4', required=True, indexed=False)\n    total_amount = DecimalProperty('5', required=True, indexed=False)\n    state = ndb.IntegerProperty('6', required=True, indexed=False) \n    updated = ndb.DateTimeProperty('7', auto_now=True, required=True, indexed=False)\n    _default_indexed = False\n    pass\n    # Expando\n    # company_address = ndb.LocalStructuredProperty(OrderAddress, '8', required=True)\n    # billing_address = ndb.LocalStructuredProperty(OrderAddress, '9', required=True)\n    # shipping_address = ndb.LocalStructuredProperty(OrderAddress, '10', required=True)\n    # reference = ndb.StringProperty('11', required=True)\n    # comment = ndb.TextProperty('12')# 64kb limit\n\n# done!\nclass OrderAddress(ndb.Expando):\n    \n    # LocalStructuredProperty model\n    name = ndb.StringProperty('1', required=True, indexed=False)\n    country = ndb.StringProperty('2', required=True, indexed=False)\n    country_code = ndb.StringProperty('3', required=True, indexed=False)\n    region = ndb.StringProperty('4', required=True, indexed=False)\n    region_code = ndb.StringProperty('5', required=True, indexed=False)\n    city = ndb.StringProperty('6', required=True, indexed=False)\n    postal_code = ndb.StringProperty('7', required=True, indexed=False)\n    street_address = ndb.StringProperty('8', required=True, indexed=False)\n    _default_indexed = False\n    pass\n    # Expando\n    # street_address2 = ndb.StringProperty('9')\n    # email = ndb.StringProperty('10')\n    # telephone = ndb.StringProperty('11')\n\n# done!\nclass OrderCurrency(ndb.Model):\n    \n    # LocalStructuredProperty model\n    # http://hg.tryton.org/modules/currency/file/tip/currency.py#l14\n    # http://en.wikipedia.org/wiki/ISO_4217\n    # http://hg.tryton.org/modules/currency/file/tip/currency.xml#l107\n    # http://bazaar.launchpad.net/~openerp/openobject-server/7.0/view/head:/openerp/addons/base/res/res_currency.py#L32\n    name = ndb.StringProperty('1', required=True, indexed=False)\n    symbol = ndb.StringProperty('2', required=True, indexed=False)\n    code = ndb.StringProperty('3', required=True, indexed=False)\n    numeric_code = ndb.StringProperty('4', indexed=False)\n    rounding = DecimalProperty('5', required=True, indexed=False)\n    digits = ndb.IntegerProperty('6', required=True, indexed=False)\n    #formating\n    grouping = ndb.StringProperty('7', required=True, indexed=False)\n    decimal_separator = ndb.StringProperty('8', required=True, indexed=False)\n    thousands_separator = ndb.StringProperty('9', indexed=False)\n    positive_sign_position = ndb.IntegerProperty('10', required=True, indexed=False)\n    negative_sign_position = ndb.IntegerProperty('11', required=True, indexed=False)\n    positive_sign = ndb.StringProperty('12', indexed=False)\n    negative_sign = ndb.StringProperty('13', indexed=False)\n    positive_currency_symbol_precedes = ndb.BooleanProperty('14', default=True, indexed=False)\n    negative_currency_symbol_precedes = ndb.BooleanProperty('15', default=True, indexed=False)\n    positive_separate_by_space = ndb.BooleanProperty('16', default=True, indexed=False)\n    negative_separate_by_space = ndb.BooleanProperty('17', default=True, indexed=False)\n\n# done!\nclass OrderLine(ndb.Expando):\n    \n    # ancestor Order, BillingOrder\n    # http://hg.tryton.org/modules/sale/file/tip/sale.py#l888\n    # http://bazaar.launchpad.net/~openerp/openobject-addons/7.0/view/head:/sale/sale.py#L649\n    # composite index: ancestor:yes - sequence\n    description = ndb.TextProperty('1', required=True)# soft limit 64kb\n    quantity = DecimalProperty('2', required=True, indexed=False)\n    product_uom = ndb.LocalStructuredProperty(OrderLineProductUOM, '3', required=True)\n    unit_price = DecimalProperty('4', required=True, indexed=False)\n    discount = DecimalProperty('5', default=0.00, indexed=False)\n    sequence = ndb.IntegerProperty('6', required=True)\n    _default_indexed = False\n    pass\n    # Expando\n    # taxes = ndb.LocalStructuredProperty(OrderLineTax, '7', repeated=True)# soft limit 500x\n    # product_category_complete_name = ndb.TextProperty('8', required=True)# soft limit 64kb\n    # product_category = ndb.KeyProperty('9', kind=ProductCategory, required=True)\n    # catalog_pricetag_reference = ndb.KeyProperty('10', kind=CatalogPricetag, required=True)\n    # product_instance_reference = ndb.KeyProperty('11', kind=ProductInstance, required=True)\n    # tax_references = ndb.KeyProperty('12', kind=StoreTax, repeated=True)# soft limit 500x\n\n# done!\nclass OrderLineProductUOM(ndb.Model):\n    \n    # LocalStructuredProperty model\n    # http://hg.tryton.org/modules/product/file/tip/uom.py#l28\n    # http://hg.tryton.org/modules/product/file/tip/uom.xml#l63 - http://hg.tryton.org/modules/product/file/tip/uom.xml#l312\n    # http://bazaar.launchpad.net/~openerp/openobject-addons/7.0/view/head:/product/product.py#L89\n    name = ndb.StringProperty('1', required=True, indexed=False)\n    symbol = ndb.StringProperty('2', required=True, indexed=False)\n    category = ndb.StringProperty('3', required=True, indexed=False)# ProductUOMCategory.name\n    rounding = DecimalProperty('4', required=True, indexed=False)\n    digits = ndb.IntegerProperty('5', required=True, indexed=False)\n\n# done!\nclass OrderLineTax(ndb.Model):\n    \n    # LocalStructuredProperty model\n    # http://hg.tryton.org/modules/account/file/tip/tax.py#l545\n    name = ndb.StringProperty('1', required=True, indexed=False)\n    amount = ndb.StringProperty('2', required=True, indexed=False)# prekompajlirane vrednosti iz UI, napr: 17.00[%] ili 10.00[c] gde je [c] = currency\n\n# done!\nclass PayPalTransaction(ndb.Model):\n    \n    # ancestor Order, BillingOrder\n    # not logged\n    # ako budemo radili analizu sa pojedinacnih ordera onda nam treba composite index: ancestor:yes - logged:desc\n    logged = ndb.DateTimeProperty('1', auto_now_add=True, required=True)\n    txn_id = ndb.StringProperty('2', required=True)\n    ipn_message = ndb.TextProperty('3', required=True)\n\n# done! contention se moze zaobici ako write-ovi na ove entitete budu explicitno izolovani preko task queue\nclass BillingLog(ndb.Model):\n    \n    # root (namespace Domain)\n    # not logged\n    logged = ndb.DateTimeProperty('1', auto_now_add=True, required=True)\n    reference = ndb.KeyProperty('2',required=True)# idempotency je moguc ako se pre inserta proverava da li je record sa tim reference-om upisan\n    amount = DecimalProperty('3', required=True, indexed=False)# ukljuciti index ako bude trebao za projection query\n    balance = DecimalProperty('4', required=True, indexed=False)# ukljuciti index ako bude trebao za projection query\n\n# done!\nclass BillingCreditAdjustment(ndb.Model):\n    \n    # root (namespace Domain)\n    # not logged\n    adjusted = ndb.DateTimeProperty('2', auto_now_add=True, required=True, indexed=False)\n    agent = ndb.KeyProperty('3', kind=User, required=True, indexed=False)\n    amount = DecimalProperty('4', required=True, indexed=False)\n    message = ndb.TextProperty('5')# soft limit 64kb - to determine char count\n    note = ndb.TextProperty('6')# soft limit 64kb - to determine char count"],[0,"\n\n\n"]],"start1":58194,"start2":58194,"length1":15,"length2":10559}]],"length":68753,"saved":false}
{"ts":1378921718028,"patch":[[{"diffs":[[0,"=True)\n\n"],[-1,"\n\n\n"],[0,"########"]],"start1":58195,"start2":58195,"length1":19,"length2":16},{"diffs":[[0," count\n\n"],[1,"################################################################################\n# OBJECT LOG - 1\n################################################################################\n\n# done!\nclass ObjectLog(ndb.Expando):\n    \n    # ancestor Any - ancestor je objekat koji se ujedno i pickle u log property, i moze biti bilo koji objekat osim pojedinih objekata koji su independent\n    # reference i type izvlacimo iz kljuca - key.parent()\n    # composite index: ???\n    logged = ndb.DateTimeProperty('1', auto_now_add=True, required=True)\n    agent = ndb.KeyProperty('2', kind=User, required=True)\n    action = ndb.IntegerProperty('3', required=True)\n    state = ndb.IntegerProperty('4', required=True)\n    _default_indexed = False\n    pass\n    # message / m = ndb.TextProperty('5')# soft limit 64kb - to determine char count\n    # note / n = ndb.TextProperty('6')# soft limit 64kb - to determine char count\n    # log / l = ndb.PickleProperty('7')\n    \n    # ovako se smanjuje storage u Datastore, i trebalo bi sprovesti to isto na sve modele\n    @classmethod\n    def _get_kind(cls):\n      return datastore_key_kinds.ObjectLog"],[0,"\n"]],"start1":68741,"start2":68741,"length1":9,"length2":1132}]],"length":69873,"saved":false}
{"ts":1378921976286,"patch":[[{"diffs":[[0," count\n\n"],[1,"################################################################################\n# MISC - 12\n################################################################################\n\n# done!\nclass Content(ndb.Model):\n    \n    # root\n    # composite index: ancestor:no - category,state,sequence\n    updated = ndb.DateTimeProperty('1', auto_now=True, required=True)\n    title = ndb.StringProperty('2', required=True)\n    category = ndb.IntegerProperty('3', required=True)\n    body = ndb.TextProperty('4', required=True)\n    sequence = ndb.IntegerProperty('5', required=True)\n    state = ndb.IntegerProperty('6', required=True)# published/unpublished\n\n# done!\nclass Image(ndb.Model):\n    \n    # base class/structured class\n    image = blobstore.BlobKeyProperty('1', required=True, indexed=False)# blob ce se implementirati na GCS\n    content_type = ndb.StringProperty('2', required=True, indexed=False)\n    size = ndb.FloatProperty('3', required=True, indexed=False)\n    width = ndb.IntegerProperty('4', required=True, indexed=False)\n    height = ndb.IntegerProperty('5', required=True, indexed=False)\n    sequence = ndb.IntegerProperty('6', required=True)\n\n# done!\nclass Country(ndb.Model):\n    \n    # root\n    # http://hg.tryton.org/modules/country/file/tip/country.py#l8\n    # http://en.wikipedia.org/wiki/ISO_3166\n    # http://hg.tryton.org/modules/country/file/tip/country.xml\n    # http://downloads.tryton.org/2.8/trytond_country-2.8.0.tar.gz\n    # http://bazaar.launchpad.net/~openerp/openobject-server/7.0/view/head:/openerp/addons/base/res/res_country.py#L42\n    # composite index: ancestor:no - active,name\n    code = ndb.StringProperty('1', required=True, indexed=False)# ukljuciti index ako bude trebao za projection query\n    name = ndb.StringProperty('2', required=True)\n    active = ndb.BooleanProperty('3', default=True)\n\n# done!\nclass CountrySubdivision(ndb.Model):\n    \n    # ancestor Country\n    # http://hg.tryton.org/modules/country/file/tip/country.py#l52\n    # http://bazaar.launchpad.net/~openerp/openobject-server/7.0/view/head:/openerp/addons/base/res/res_country.py#L86\n    # koliko cemo drilldown u ovoj strukturi zavisi od kasnijih odluka u vezi povezivanja lokativnih informacija sa informacijama ovog modela..\n    # composite index: ancestor:yes - name; ancestor:yes - active,name\n    parent_record = ndb.KeyProperty('1', kind=CountrySubdivision, indexed=False)\n    code = ndb.StringProperty('2', required=True, indexed=False)# ukljuciti index ako bude trebao za projection query\n    name = ndb.StringProperty('3', required=True)\n    type = ndb.IntegerProperty('4', required=True, indexed=False)\n    active = ndb.BooleanProperty('5', default=True)\n\n# done!\nclass Location(ndb.Expando):\n    \n    # base class/structured class\n    country = ndb.KeyProperty('1', kind=Country, required=True, indexed=False)\n    _default_indexed = False\n    pass\n    # Expando\n    # region = ndb.KeyProperty('2', kind=CountrySubdivision)# ako je potreban string val onda se ovo preskace \n    # region = ndb.StringProperty('2')# ako je potreban key val onda se ovo preksace\n    # postal_code_from = ndb.StringProperty('3')\n    # postal_code_to = ndb.StringProperty('4')\n    # city = ndb.StringProperty('5')# ako se javi potreba za ovim ??\n\n# done!\nclass ProductCategory(ndb.Model):\n    \n    # root\n    # http://hg.tryton.org/modules/product/file/tip/category.py#l8\n    # https://support.google.com/merchants/answer/1705911\n    # http://bazaar.launchpad.net/~openerp/openobject-addons/7.0/view/head:/product/product.py#L227\n    # composite index: ancestor:no - state,name\n    parent_record = ndb.KeyProperty('1', kind=ProductCategory, indexed=False)\n    name = ndb.StringProperty('2', required=True)\n    complete_name = ndb.TextProperty('3', required=True)# da je ovo indexable bilo bi idealno za projection query\n    state = ndb.IntegerProperty('4', required=True)\n\n# done!\nclass ProductUOMCategory(ndb.Model):\n    \n    # root\n    # http://hg.tryton.org/modules/product/file/tip/uom.py#l16\n    # http://bazaar.launchpad.net/~openerp/openobject-addons/7.0/view/head:/product/product.py#L81\n    # mozda da ovi entiteti budu non-deletable i non-editable ??\n    name = ndb.StringProperty('1', required=True)\n\n# done!\nclass ProductUOM(ndb.Model):\n    \n    # ancestor ProductUOMCategory\n    # http://hg.tryton.org/modules/product/file/tip/uom.py#l28\n    # http://hg.tryton.org/modules/product/file/tip/uom.xml#l63 - http://hg.tryton.org/modules/product/file/tip/uom.xml#l312\n    # http://bazaar.launchpad.net/~openerp/openobject-addons/7.0/view/head:/product/product.py#L89\n    # mozda da ovi entiteti budu non-deletable i non-editable ??\n    # composite index: ancestor:no - active,name\n    name = ndb.StringProperty('1', required=True)\n    symbol = ndb.StringProperty('2', required=True, indexed=False)# ukljuciti index ako bude trebao za projection query\n    rate = DecimalProperty('3', required=True, indexed=False)# The coefficient for the formula: 1 (base unit) = coef (this unit) - digits=(12, 12)\n    factor = DecimalProperty('4', required=True, indexed=False)# The coefficient for the formula: coef (base unit) = 1 (this unit) - digits=(12, 12)\n    rounding = DecimalProperty('5', required=True, indexed=False)# Rounding Precision - digits=(12, 12)\n    digits = ndb.IntegerProperty('6', required=True, indexed=False)\n    active = ndb.BooleanProperty('7', default=True)\n\n# done!\nclass Currency(ndb.Model):\n    \n    # root\n    # http://hg.tryton.org/modules/currency/file/tip/currency.py#l14\n    # http://en.wikipedia.org/wiki/ISO_4217\n    # http://hg.tryton.org/modules/currency/file/tip/currency.xml#l107\n    # http://bazaar.launchpad.net/~openerp/openobject-server/7.0/view/head:/openerp/addons/base/res/res_currency.py#L32\n    # composite index: ancestor:no - active,name\n    name = ndb.StringProperty('1', required=True)\n    symbol = ndb.StringProperty('2', required=True, indexed=False)# ukljuciti index ako bude trebao za projection query\n    code = ndb.StringProperty('3', required=True, indexed=False)# ukljuciti index ako bude trebao za projection query\n    numeric_code = ndb.StringProperty('4', indexed=False)\n    rounding = DecimalProperty('5', required=True, indexed=False)\n    digits = ndb.IntegerProperty('6', required=True, indexed=False)\n    active = ndb.BooleanProperty('7', default=True)\n    #formating\n    grouping = ndb.StringProperty('8', required=True, indexed=False)\n    decimal_separator = ndb.StringProperty('9', required=True, indexed=False)\n    thousands_separator = ndb.StringProperty('10', indexed=False)\n    positive_sign_position = ndb.IntegerProperty('11', required=True, indexed=False)\n    negative_sign_position = ndb.IntegerProperty('12', required=True, indexed=False)\n    positive_sign = ndb.StringProperty('13', indexed=False)\n    negative_sign = ndb.StringProperty('14', indexed=False)\n    positive_currency_symbol_precedes = ndb.BooleanProperty('15', default=True, indexed=False)\n    negative_currency_symbol_precedes = ndb.BooleanProperty('16', default=True, indexed=False)\n    positive_separate_by_space = ndb.BooleanProperty('17', default=True, indexed=False)\n    negative_separate_by_space = ndb.BooleanProperty('18', default=True, indexed=False)\n\n# done!\n# ostaje da se ispita u preprodukciji!!\nclass Message(ndb.Model):\n    \n    # root\n    outlet = ndb.IntegerProperty('1', required=True, indexed=False)\n    group = ndb.IntegerProperty('2', required=True, indexed=False)\n    state = ndb.IntegerProperty('3', required=True)\n\n"],[0,"########"]],"start1":68741,"start2":68741,"length1":16,"length2":7486}]],"length":77343,"saved":false}
{"ts":1378922020131,"patch":[[{"diffs":[[0,"MISC - 1"],[-1,"2"],[1,"0"],[0,"\n#######"]],"start1":68832,"start2":68832,"length1":17,"length2":17}]],"length":77343,"saved":false}
{"ts":1378922071913,"patch":[[{"diffs":[[0,"OMAIN - "],[1,"20"],[0,"\n#######"]],"start1":29382,"start2":29382,"length1":16,"length2":18}]],"length":77345,"saved":false}
{"ts":1378922082655,"patch":[[{"diffs":[[0," User - "],[1,"3"],[0,"\n#######"]],"start1":3048,"start2":3048,"length1":16,"length2":17}]],"length":77346,"saved":false}
{"ts":1378922793336,"patch":[[{"diffs":[[0,"al\n\n"],[-1,"################################################################################\n# User - 3\n################################################################################\n\n# done!\nclass User(ndb.Expando):\n    \n    # root\n    state = ndb.IntegerProperty('1', required=True)\n    emails = ndb.StringProperty('2', repeated=True)# soft limit 100x\n    identities = ndb.StructuredProperty(UserIdentity, '3', repeated=True)# soft limit 100x\n    _default_indexed = False\n    pass\n    #Expando\n    \n    _KIND = 2\n    \n    OBJECT_DEFAULT_STATE = 'active'\n    \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state\n        # Ne znam da li je predvidjeno ovde da moze biti vise tranzicija/akcija koje vode do istog state-a,\n        # sto ce biti slucaj sa verovatno mnogim modelima.\n        # broj 0 je rezervisan za none (Stateless Models) i ne koristi se za definiciju validnih state-ova\n        'active' : (1, ),\n        'suspended' : (2, ),\n    }\n    \n    OBJECT_ACTIONS = {\n       'register' : 1,\n       'update' : 2,\n       'login' : 3,\n       'logout' : 4,\n       'suspend' : 5,\n       'activate' : 6,\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'activate' : {\n             # from where to where this transition can be accomplished?\n            'from' : ('suspended',),\n            'to' : ('active',),\n         },\n        'suspend' : {\n           'from' : ('active', ),\n           'to'   : ('suspended',),\n        },\n    }\n    \n    # Ova akcija nastaje prilikom prve autentikacije kada korisnik nije jos registrovan.\n    # Ukoliko se prilikom \"login\" akcije ustanovi da korisnik nikada nije evidentiran u bazi, nastupa akcija \"register\". \n    @ndb.transactional\n    def register():\n        # ovu akciju moze izvrsiti samo neregistrovani neautenticirani agent.\n        user = User(state='active', emails=['user@email.com',], identities=[UserIdentity(identity='abc123', email='user@email.com', associated=True, primary=True),])\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent=user_key, action='register', state=user.state, log=user)\n        object_log.put()\n        # UserIPAddress se pravi nakon pravljenja ObjectLog-a zato sto se ne loguje.\n        user_ip_address = UserIPAddress(parent=user_key, ip_address='127.0.0.1')\n        user_ip_address.put()\n    \n    # Ova akcija radi insert/update/delete na neki prop. (izuzev state) u User objektu.\n    @ndb.transactional\n    def update():\n        user.emails = ['user@email.com',]\n        user.identities = [UserIdentity(identity='abc123', email='user@email.com', associated=True, primary=True),]\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent=user_key, action='update', state=user.state, log=user)\n        object_log.put()\n        # ukoliko se u listi user.identities promenio prop. user.identities.primary, \n        # radi se potraga za eventualnim BuyerCollection entietom usera koji je imao prethodnu email adresu, \n        # i radi se buyer_collection.primary_email prop.\n    \n    # Ova akcija se izvrsava svaki put kada neautenticirani korisnik stupi u proces autentikacije.\n    # Prvo se proverava da li je korisnik vec registrovan. Ukoliko User ne postoji onda se prelazi na akciju \"register\".\n    # Ukoliko user postoji, onda se dalje ispituje. \n    # Proverava se da li ima nekih izmena na postojecim podacima, i ukoliko ima, onda se poziva \"update\" akcija.\n    # Dalje se proverava da li je useru dozvoljen login (User.state == 'active'). Ako mu je dozvoljen login onda se izvrsava \"login\" akcija.\n    @ndb.transactional\n    def login():\n        # ovde bi mogla da stoji provera continue if(User.state == 'active'), ili van ove funkcije, videcemo.\n        object_log = ObjectLog(parent=user_key, agent=user_key, action='login', state=user.state)\n        object_log.put()\n        # UserIPAddress se pravi nakon pravljenja ObjectLog-a zato sto se ne loguje.\n        user_ip_address = UserIPAddress(parent=user_key, ip_address='127.0.0.1')\n        user_ip_address.put()\n    \n    # Ova akcija se izvrsava svaki put kada autenticirani korisnik stupi u proces deautentikacije.\n    @ndb.transactional\n    def logout():\n        object_log = ObjectLog(parent=user_key, agent='user_key/agent_key', action='logout', state=user.state)\n        object_log.put()\n    \n    # Ova akcija sluzi za suspenziju aktivnog korisnika, i izvrsava je privilegovani/administrativni agent.\n    # Treba obratiti paznju na to da suspenzija usera ujedno znaci i izuzimanje svih negativnih i neutralnih feedbackova koje je user ostavio dok je bio aktivan.\n    ''' Suspenzija user account-a zabranjuje njegovom vlasniku autenticirani pristup na mstyle, \n    i deaktivira sve negativne i neutralne feedback-ove koji su sa ovog user account-a ostavljeni. \n    Ni jedan asocirani email suspendovanog korisnickog racuna se vise ne moze upotrebiti na mstyle \n    (za otvaranje novog account-a, ili neke druge operacije). \n    Account koji je suspendovan se moze opet reaktivirati od strane administratora sistema. '''\n    @ndb.transactional\n    def suspend():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'suspend-User'.\n        # akcija se moze pozvati samo ako je user.state == 'active'.\n        user.state = 'suspended'\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent='agent_key', action='suspend', state=user.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n        # poziva se akcija \"logout\";\n        User.logout()\n    \n    # Ova akcija sluzi za aktiviranje suspendovanog korisnika i izvrsava je privilegovani/administrativni agent.\n    # Treba obratiti paznju na to da aktivacija usera ujedno znaci i vracanje svih negativnih i neutralnih feedbackova koje je user ostavio dok je bio aktivan, a koji su bili izuzeti dok je bio suspendovan.\n    # Aktivni user account je u potpunosti funkcionalan i operativan.\n    @ndb.transactional\n    def activate():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'activate-User'.\n        # akcija se moze pozvati samo ako je user.state == 'suspended'.\n        user.state = 'active'\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent='agent_key', action='activate', state=user.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n\n# done!\nclass UserIdentity(ndb.Model):\n    \n    # StructuredProperty model\n    identity = ndb.StringProperty('1', required=True)# spojen je i provider name sa id-jem\n    email = ndb.StringProperty('2', required=True)\n    associated = ndb.BooleanProperty('3', default=True)\n    primary = ndb.BooleanProperty('4', default=True)\n\n# done! mozemo li ovo da stavljamo u app engine log ? - ovo sam verovatno i ranje pitao...\nclass UserIPAddress(ndb.Model):\n    \n    # ancestor User\n    # not logged\n    # ako budemo radili per user istragu loga onda nam treba composite index: ancestor:yes - logged:desc\n    logged = ndb.DateTimeProperty('1', auto_now_add=True, required=True)\n    ip_address = ndb.StringProperty('2', required=True, indexed=False)\n\n################################################################################\n# BUYER - 4\n################################################################################\n\n# done!\nclass BuyerAddress(ndb.Expando):\n    \n    # ancestor User\n    # composite index: ancestor:yes - name\n    name = ndb.StringProperty('1', required=True)\n    country = ndb.KeyProperty('2', kind=Country, required=True, indexed=False)\n    city = ndb.StringProperty('3', required=True, indexed=False)\n    postal_code = ndb.StringProperty('4', required=True, indexed=False)\n    street_address = ndb.StringProperty('5', required=True, indexed=False)\n    default_shipping = ndb.BooleanProperty('6', default=True, indexed=False)\n    default_billing = ndb.BooleanProperty('7', default=True, indexed=False)\n    _default_indexed = False\n    pass\n    # Expando\n    # naredna dva polja su required!!!\n    # region = ndb.KeyProperty('8', kind=CountrySubdivision, required=True)# ako je potreban string val onda se ovo preskace \n    # region = ndb.StringProperty('8', required=True)# ako je potreban key val onda se ovo preskace\n    # street_address2 = ndb.StringProperty('9')\n    # email = ndb.StringProperty('10')\n    # telephone = ndb.StringProperty('11')\n    \n    _KIND = 18\n    \n    OBJECT_DEFAULT_STATE = 'none'\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'delete' : 3,\n    }\n    \n    # Pravi novu adresu korisnika\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        buyer_address = BuyerAddress(parent=user_key, name='Home', country='82736563', city='Beverly Hills', postal_code='90210', street_address='First Street, 10', region='656776533')\n        buyer_address_key = buyer_address.put()\n        object_log = ObjectLog(parent=buyer_address_key, agent=user_key, action='create', state='none', log=buyer_address)\n        object_log.put()\n    \n    # Azurira postojecu adresu korisnika\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_address.parent == agent).\n        buyer_address.name = 'Home in Miami'\n        buyer_address.country = '82736563'\n        buyer_address.city = 'Miami'\n        buyer_address.postal_code = '26547'\n        buyer_address.street_address = 'Second Street, 10'\n        buyer_address.region = '514133'\n        buyer_address_key = buyer_address.put()\n        object_log = ObjectLog(parent=buyer_address_key, agent=user_key, action='update', state='none', log=buyer_address)\n        object_log.put()\n    \n    # Brise postojecu adresu korisnika\n    @ndb.transactional\n    def delete():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_address.parent == agent).\n        object_log = ObjectLog(parent=buyer_address_key, agent=user_key, action='delete', state='none')\n        object_log.put()\n        buyer_address_key.delete()\n\n# done!\nclass BuyerCollection(ndb.Model):\n    \n    # ancestor User\n    # mozda bude trebao index na primary_email radi mogucnosti update-a kada user promeni primarnu email adresu na svom profilu\n    # composite index: ancestor:yes - name\n    name = ndb.StringProperty('1', required=True)\n    notifications = ndb.BooleanProperty('2', default=False)\n    primary_email = ndb.StringProperty('3', required=True, indexed=False)\n    \n    _KIND = 19\n    \n    OBJECT_DEFAULT_STATE = 'none'\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'delete' : 3,\n    }\n    \n    # Pravi novu kolekciju za korisnika\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        for identity in user.identities:\n            if(identity.primary == True):\n                user_primary_email = identity.email\n                break\n        buyer_collection = BuyerCollection(parent=user_key, name='Favorites', notifications=True, primary_email=user_primary_email)\n        buyer_collection_key = buyer_collection.put()\n        object_log = ObjectLog(parent=buyer_collection_key, agent=user_key, action='create', state='none', log=buyer_collection)\n        object_log.put()\n    \n    # Azurira postojecu kolekciju korisnika\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection.parent == agent).\n        buyer_collection.name = 'Shoes'\n        buyer_collection.notifications = True\n        for identity in user.identities:\n            if(identity.primary == True):\n                user_primary_email = identity.email\n                break\n        buyer_collection.primary_email = user_primary_email\n        buyer_collection_key = buyer_collection.put()\n        object_log = ObjectLog(parent=buyer_collection_key, agent=user_key, action='update', state='none', log=buyer_collection)\n        object_log.put()\n    \n    # Brise postojecu kolekciju korisnika\n    @ndb.transactional\n    def delete():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection.parent == agent).\n        object_log = ObjectLog(parent=buyer_collection_key, agent=user_key, action='delete', state='none')\n        object_log.put()\n        buyer_collection_key.delete()\n\n# done!\nclass BuyerCollectionStore(ndb.Model):\n    \n    # ancestor User\n    store = ndb.KeyProperty('1', kind=Store, required=True)\n    collections = ndb.KeyProperty('2', kind=BuyerCollection, repeated=True)# soft limit 500x\n    \n    _KIND = 20\n    \n    OBJECT_DEFAULT_STATE = 'none'\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'delete' : 3,\n    }\n    \n    # Dodaje novi store u korisnikovu listu i odredjuje clanstvo u kolekcijama korisnika\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        buyer_collection_store = BuyerCollectionStore(parent=user_key, store='7464536', collections=['1234'])\n        buyer_collection_store_key = buyer_collection_store.put()\n        object_log = ObjectLog(parent=buyer_collection_store_key, agent=user_key, action='create', state='none', log=buyer_collection_store)\n        object_log.put()\n        # izaziva se update AggregateBuyerCollectionCatalog preko task queue\n    \n    # Menja clanstvo store u kolekcijama korisnika\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection_store.parent == agent).\n        buyer_collection_store.collections = ['1234', '56433']\n        buyer_collection_store_key = buyer_collection_store.put()\n        object_log = ObjectLog(parent=buyer_collection_store_key, agent=user_key, action='update', state='none', log=buyer_collection_store)\n        object_log.put()\n        # izaziva se update AggregateBuyerCollectionCatalog preko task queue\n    \n    # Brise store iz korisnikove liste\n    @ndb.transactional\n    def delete():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection_store.parent == agent).\n        object_log = ObjectLog(parent=buyer_collection_store_key, agent=user_key, action='delete', state='none')\n        object_log.put()\n        buyer_collection_store_key.delete()\n        # izaziva se update AggregateBuyerCollectionCatalog preko task queue\n        # ndb.delete_multi(AggregateBuyerCollectionCatalog.query(AggregateBuyerCollectionCatalog.store == buyer_collection_store.store, ancestor=user_key))\n\n# done! contention se moze zaobici ako write-ovi na ove entitete budu explicitno izolovani preko task queue\nclass AggregateBuyerCollectionCatalog(ndb.Model):\n    \n    # ancestor User\n    # not logged\n    # task queue radi agregaciju prilikom nekih promena na store-u\n    # mogao bi da se uvede index na collections radi filtera: AggregateBuyerCollectionCatalog.collections = 'collection', \n    # ovo moze biti dobra situacija za upotrebu MapReduce ??\n    # composite index: ancestor:yes - catalog_published_date:desc\n    store = ndb.KeyProperty('1', kind=Store, required=True)\n    collections = ndb.KeyProperty('2', kind=BuyerCollection, repeated=True, indexed=False)# soft limit 500x\n    catalog = ndb.KeyProperty('3', kind=Catalog, required=True, indexed=False)\n    catalog_cover = blobstore.BlobKeyProperty('4', required=True, indexed=False)# blob ce se implementirati na GCS\n    catalog_published_date = ndb.DateTimeProperty('5', required=True)\n\n################################################################################\n# USER REQUEST - 2\n################################################################################\n\n# done!\nclass FeedbackRequest(ndb.Model):\n    \n    # ancestor User\n    # ako hocemo da dozvolimo sva sortiranja, i dodatni filter po state-u uz sortiranje, onda nam trebaju slecedi indexi\n    # composite index:\n    # ancestor:yes - updated:desc; ancestor:yes - created:desc;\n    # ancestor:yes - state,updated:desc; ancestor:yes - state,created:desc\n    reference = ndb.StringProperty('1', required=True, indexed=False)\n    state = ndb.IntegerProperty('2', required=True)\n    updated = ndb.DateTimeProperty('3', auto_now=True, required=True)\n    created = ndb.DateTimeProperty('4', auto_now_add=True, required=True)\n    \n    # primer helper funkcije u slucajevima gde se ne koristi ancestor mehanizam za pristup relacijama\n    @property\n    def logs(self):\n      return ObjectLog.query(ancestor = self.key())\n    \n    _KIND = 8\n    \n    OBJECT_DEFAULT_STATE = 'new'\n    \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state\n        # ne znam da li je predvidjeno ovde da moze biti vise tranzicija/akcija koje vode do istog state-a,\n        # sto ce biti slucaj sa verovatno mnogim modelima.\n        # broj 0 je rezervisan za state none (Stateless Models) i ne koristi se za definiciju validnih state-ova\n        'new' : (1, ),\n        'reviewing' : (2, ),\n        'duplicate' : (3, ),\n        'accepted' : (4, ),\n        'dismissed' : (5, ),\n    }\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'review' : 3,\n       'close' : 4,\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'review' : {\n            'from' : ('new',),\n            'to' : ('reviewing',),\n         },\n        'close' : {\n           'from' : ('reviewing', ),\n           'to'   : ('duplicate', 'accepted', 'dismissed',),\n        },\n    }\n    \n    # Ova akcija sluzi za slanje feedback-a miraclestyle timu od strane krajnjih korisnika.\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        feedback_request = FeedbackRequest(parent=user_key, reference='https://www,miraclestyle.com/...', state='new')\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=user_key, action='create', state=feedback_request.state, message='poruka od agenta - obavezno polje!')\n        object_log.put()\n    \n    # Ova akcija sluzi za insert ObjectLog-a koji je descendant FeedbackRequest entitetu.\n    # Insertom ObjectLog-a dozvoljeno je unosenje poruke (i privatnog komentara), sto je i smisao ove akcije.\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'update-FeedbackRequest'. / ? # ovu akciju moze izvrsiti samo entity owner (feedback_request.parent == agent) ili agent koji ima globalnu dozvolu 'update-FeedbackRequest'.\n        # Radi se update FeedbackRequest-a bez izmena na bilo koji prop. (u cilju izazivanja promene na FeedbackRequest.updated prop.)\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=agent_key, action='update', state=feedback_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje FeedbackRequest entiteta u 'reviewing'.\n    @ndb.transactional\n    def review():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'review-FeedbackRequest'.\n        # akcija se moze pozvati samo ako je feedback_request.state == 'new'.\n        feedback_request.state = 'reviewing'\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=agent_key, action='review', state=feedback_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje FeedbackRequest entiteta u 'duplicate', 'accepted', ili 'dismissed'.\n    @ndb.transactional\n    def close():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'close-FeedbackRequest'.\n        # akcija se moze pozvati samo ako je feedback_request.state == 'reviewing'.\n        feedback_request.state = 'duplicate' | 'accepted' | 'dismissed'\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=agent_key, action='close', state=feedback_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n\n# done!\nclass SupportRequest(ndb.Model):\n    \n    # ancestor User\n    # ako uopste bude vidljivo useru onda mozemo razmatrati indexing\n    # ako hocemo da dozvolimo sva sortiranja, i dodatni filter po state-u uz sortiranje, onda nam trebaju slecedi indexi\n    # composite index:\n    # ancestor:yes - updated:desc; ancestor:yes - created:desc;\n    # ancestor:yes - state,updated:desc; ancestor:yes - state,created:desc\n    reference = ndb.StringProperty('1', required=True, indexed=False)\n    state = ndb.IntegerProperty('2', required=True)\n    updated = ndb.DateTimeProperty('3', auto_now=True, required=True)\n    created = ndb.DateTimeProperty('4', auto_now_add=True, required=True)\n    \n    _KIND = 9\n    \n    OBJECT_DEFAULT_STATE = 'new'\n    \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state\n        # ne znam da li je predvidjeno ovde da moze biti vise tranzicija/akcija koje vode do istog state-a,\n        # sto ce biti slucaj sa verovatno mnogim modelima.\n        # broj 0 je rezervisan za state none (Stateless Models) i ne koristi se za definiciju validnih state-ova\n        'new' : (1, ),\n        'opened' : (2, ),\n        'awaiting_closure' : (3, ),\n        'closed' : (4, ),\n    }\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'open' : 3,\n       'propose_close' : 4,\n       'close' : 5,\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'open' : {\n            'from' : ('new',),\n            'to' : ('opened',),\n         },\n        'propose_close' : {\n           'from' : ('opened', ),\n           'to'   : ('awaiting_closure',),\n        },\n        'close' : {\n           'from' : ('opened', 'awaiting_closure',),\n           'to'   : ('closed',),\n        },\n    }\n    \n    # Ova akcija krajnjem korisniku sluzi za pravljenje zahteva za pomoc (ticket-a) od miraclestyle tima.\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        support_request = SupportRequest(parent=user_key, reference='https://www,miraclestyle.com/...', state='new')\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=user_key, action='create', state=support_request.state, message='poruka od agenta - obavezno polje!')\n        object_log.put()\n    \n    # Ova akcija sluzi za insert ObjectLog-a koji je descendant SupportRequest entitetu.\n    # Insertom ObjectLog-a dozvoljeno je unosenje poruke (i privatnog komentara), sto je i smisao ove akcije.\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (support_request.parent == agent) ili agent koji ima globalnu dozvolu 'update-SupportRequest'\n        # Radi se update SupportRequest-a bez izmena na bilo koji prop. (u cilju izazivanja promene na SupportRequest.updated prop.)\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='update', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje SupportRequest entiteta u 'opened'.\n    @ndb.transactional\n    def open():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'open-SupportRequest'.\n        # akcija se moze pozvati samo ako je support_request.state == 'new'.\n        support_request.state = 'opened'\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='open', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje SupportRequest entiteta u 'awaiting_closure'.\n    @ndb.transactional\n    def propose_close():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'propose_close-SupportRequest'.\n        # akcija se moze pozvati samo ako je support_request.state == 'opened'.\n        support_request.state = 'awaiting_closure'\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='propose_close', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom agent menja stanje SupportRequest entiteta u 'closed'.\n    @ndb.transactional\n    def close():\n        # ovu akciju moze izvrsiti samo entity owner (support_request.parent == agent) ili agent koji ima globalnu dozvolu 'close-SupportRequest' (sto ce verovatno imati sistemski account koji ce preko cron-a izvrsiti akciju).\n        # akcija se moze pozvati samo ako je support_request.state == 'opened' ili support_request.state == 'awaiting_closure'.\n        support_request.state = 'closed'\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='close', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n\n"],[0,"####"]],"start1":2962,"start2":2962,"length1":26341,"length2":8},{"diffs":[[0,"required=True)\n\n"],[1,"################################################################################\n# User - 3\n################################################################################\n\n# done!\nclass User(ndb.Expando):\n    \n    # root\n    state = ndb.IntegerProperty('1', required=True)\n    emails = ndb.StringProperty('2', repeated=True)# soft limit 100x\n    identities = ndb.StructuredProperty(UserIdentity, '3', repeated=True)# soft limit 100x\n    _default_indexed = False\n    pass\n    #Expando\n    \n    _KIND = 2\n    \n    OBJECT_DEFAULT_STATE = 'active'\n    \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state\n        # Ne znam da li je predvidjeno ovde da moze biti vise tranzicija/akcija koje vode do istog state-a,\n        # sto ce biti slucaj sa verovatno mnogim modelima.\n        # broj 0 je rezervisan za none (Stateless Models) i ne koristi se za definiciju validnih state-ova\n        'active' : (1, ),\n        'suspended' : (2, ),\n    }\n    \n    OBJECT_ACTIONS = {\n       'register' : 1,\n       'update' : 2,\n       'login' : 3,\n       'logout' : 4,\n       'suspend' : 5,\n       'activate' : 6,\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'activate' : {\n             # from where to where this transition can be accomplished?\n            'from' : ('suspended',),\n            'to' : ('active',),\n         },\n        'suspend' : {\n           'from' : ('active', ),\n           'to'   : ('suspended',),\n        },\n    }\n    \n    # Ova akcija nastaje prilikom prve autentikacije kada korisnik nije jos registrovan.\n    # Ukoliko se prilikom \"login\" akcije ustanovi da korisnik nikada nije evidentiran u bazi, nastupa akcija \"register\". \n    @ndb.transactional\n    def register():\n        # ovu akciju moze izvrsiti samo neregistrovani neautenticirani agent.\n        user = User(state='active', emails=['user@email.com',], identities=[UserIdentity(identity='abc123', email='user@email.com', associated=True, primary=True),])\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent=user_key, action='register', state=user.state, log=user)\n        object_log.put()\n        # UserIPAddress se pravi nakon pravljenja ObjectLog-a zato sto se ne loguje.\n        user_ip_address = UserIPAddress(parent=user_key, ip_address='127.0.0.1')\n        user_ip_address.put()\n    \n    # Ova akcija radi insert/update/delete na neki prop. (izuzev state) u User objektu.\n    @ndb.transactional\n    def update():\n        user.emails = ['user@email.com',]\n        user.identities = [UserIdentity(identity='abc123', email='user@email.com', associated=True, primary=True),]\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent=user_key, action='update', state=user.state, log=user)\n        object_log.put()\n        # ukoliko se u listi user.identities promenio prop. user.identities.primary, \n        # radi se potraga za eventualnim BuyerCollection entietom usera koji je imao prethodnu email adresu, \n        # i radi se buyer_collection.primary_email prop.\n    \n    # Ova akcija se izvrsava svaki put kada neautenticirani korisnik stupi u proces autentikacije.\n    # Prvo se proverava da li je korisnik vec registrovan. Ukoliko User ne postoji onda se prelazi na akciju \"register\".\n    # Ukoliko user postoji, onda se dalje ispituje. \n    # Proverava se da li ima nekih izmena na postojecim podacima, i ukoliko ima, onda se poziva \"update\" akcija.\n    # Dalje se proverava da li je useru dozvoljen login (User.state == 'active'). Ako mu je dozvoljen login onda se izvrsava \"login\" akcija.\n    @ndb.transactional\n    def login():\n        # ovde bi mogla da stoji provera continue if(User.state == 'active'), ili van ove funkcije, videcemo.\n        object_log = ObjectLog(parent=user_key, agent=user_key, action='login', state=user.state)\n        object_log.put()\n        # UserIPAddress se pravi nakon pravljenja ObjectLog-a zato sto se ne loguje.\n        user_ip_address = UserIPAddress(parent=user_key, ip_address='127.0.0.1')\n        user_ip_address.put()\n    \n    # Ova akcija se izvrsava svaki put kada autenticirani korisnik stupi u proces deautentikacije.\n    @ndb.transactional\n    def logout():\n        object_log = ObjectLog(parent=user_key, agent='user_key/agent_key', action='logout', state=user.state)\n        object_log.put()\n    \n    # Ova akcija sluzi za suspenziju aktivnog korisnika, i izvrsava je privilegovani/administrativni agent.\n    # Treba obratiti paznju na to da suspenzija usera ujedno znaci i izuzimanje svih negativnih i neutralnih feedbackova koje je user ostavio dok je bio aktivan.\n    ''' Suspenzija user account-a zabranjuje njegovom vlasniku autenticirani pristup na mstyle, \n    i deaktivira sve negativne i neutralne feedback-ove koji su sa ovog user account-a ostavljeni. \n    Ni jedan asocirani email suspendovanog korisnickog racuna se vise ne moze upotrebiti na mstyle \n    (za otvaranje novog account-a, ili neke druge operacije). \n    Account koji je suspendovan se moze opet reaktivirati od strane administratora sistema. '''\n    @ndb.transactional\n    def suspend():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'suspend-User'.\n        # akcija se moze pozvati samo ako je user.state == 'active'.\n        user.state = 'suspended'\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent='agent_key', action='suspend', state=user.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n        # poziva se akcija \"logout\";\n        User.logout()\n    \n    # Ova akcija sluzi za aktiviranje suspendovanog korisnika i izvrsava je privilegovani/administrativni agent.\n    # Treba obratiti paznju na to da aktivacija usera ujedno znaci i vracanje svih negativnih i neutralnih feedbackova koje je user ostavio dok je bio aktivan, a koji su bili izuzeti dok je bio suspendovan.\n    # Aktivni user account je u potpunosti funkcionalan i operativan.\n    @ndb.transactional\n    def activate():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'activate-User'.\n        # akcija se moze pozvati samo ako je user.state == 'suspended'.\n        user.state = 'active'\n        user_key = user.put()\n        object_log = ObjectLog(parent=user_key, agent='agent_key', action='activate', state=user.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n\n# done!\nclass UserIdentity(ndb.Model):\n    \n    # StructuredProperty model\n    identity = ndb.StringProperty('1', required=True)# spojen je i provider name sa id-jem\n    email = ndb.StringProperty('2', required=True)\n    associated = ndb.BooleanProperty('3', default=True)\n    primary = ndb.BooleanProperty('4', default=True)\n\n# done! mozemo li ovo da stavljamo u app engine log ? - ovo sam verovatno i ranje pitao...\nclass UserIPAddress(ndb.Model):\n    \n    # ancestor User\n    # not logged\n    # ako budemo radili per user istragu loga onda nam treba composite index: ancestor:yes - logged:desc\n    logged = ndb.DateTimeProperty('1', auto_now_add=True, required=True)\n    ip_address = ndb.StringProperty('2', required=True, indexed=False)\n\n################################################################################\n# BUYER - 4\n################################################################################\n\n# done!\nclass BuyerAddress(ndb.Expando):\n    \n    # ancestor User\n    # composite index: ancestor:yes - name\n    name = ndb.StringProperty('1', required=True)\n    country = ndb.KeyProperty('2', kind=Country, required=True, indexed=False)\n    city = ndb.StringProperty('3', required=True, indexed=False)\n    postal_code = ndb.StringProperty('4', required=True, indexed=False)\n    street_address = ndb.StringProperty('5', required=True, indexed=False)\n    default_shipping = ndb.BooleanProperty('6', default=True, indexed=False)\n    default_billing = ndb.BooleanProperty('7', default=True, indexed=False)\n    _default_indexed = False\n    pass\n    # Expando\n    # naredna dva polja su required!!!\n    # region = ndb.KeyProperty('8', kind=CountrySubdivision, required=True)# ako je potreban string val onda se ovo preskace \n    # region = ndb.StringProperty('8', required=True)# ako je potreban key val onda se ovo preskace\n    # street_address2 = ndb.StringProperty('9')\n    # email = ndb.StringProperty('10')\n    # telephone = ndb.StringProperty('11')\n    \n    _KIND = 18\n    \n    OBJECT_DEFAULT_STATE = 'none'\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'delete' : 3,\n    }\n    \n    # Pravi novu adresu korisnika\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        buyer_address = BuyerAddress(parent=user_key, name='Home', country='82736563', city='Beverly Hills', postal_code='90210', street_address='First Street, 10', region='656776533')\n        buyer_address_key = buyer_address.put()\n        object_log = ObjectLog(parent=buyer_address_key, agent=user_key, action='create', state='none', log=buyer_address)\n        object_log.put()\n    \n    # Azurira postojecu adresu korisnika\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_address.parent == agent).\n        buyer_address.name = 'Home in Miami'\n        buyer_address.country = '82736563'\n        buyer_address.city = 'Miami'\n        buyer_address.postal_code = '26547'\n        buyer_address.street_address = 'Second Street, 10'\n        buyer_address.region = '514133'\n        buyer_address_key = buyer_address.put()\n        object_log = ObjectLog(parent=buyer_address_key, agent=user_key, action='update', state='none', log=buyer_address)\n        object_log.put()\n    \n    # Brise postojecu adresu korisnika\n    @ndb.transactional\n    def delete():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_address.parent == agent).\n        object_log = ObjectLog(parent=buyer_address_key, agent=user_key, action='delete', state='none')\n        object_log.put()\n        buyer_address_key.delete()\n\n# done!\nclass BuyerCollection(ndb.Model):\n    \n    # ancestor User\n    # mozda bude trebao index na primary_email radi mogucnosti update-a kada user promeni primarnu email adresu na svom profilu\n    # composite index: ancestor:yes - name\n    name = ndb.StringProperty('1', required=True)\n    notifications = ndb.BooleanProperty('2', default=False)\n    primary_email = ndb.StringProperty('3', required=True, indexed=False)\n    \n    _KIND = 19\n    \n    OBJECT_DEFAULT_STATE = 'none'\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'delete' : 3,\n    }\n    \n    # Pravi novu kolekciju za korisnika\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        for identity in user.identities:\n            if(identity.primary == True):\n                user_primary_email = identity.email\n                break\n        buyer_collection = BuyerCollection(parent=user_key, name='Favorites', notifications=True, primary_email=user_primary_email)\n        buyer_collection_key = buyer_collection.put()\n        object_log = ObjectLog(parent=buyer_collection_key, agent=user_key, action='create', state='none', log=buyer_collection)\n        object_log.put()\n    \n    # Azurira postojecu kolekciju korisnika\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection.parent == agent).\n        buyer_collection.name = 'Shoes'\n        buyer_collection.notifications = True\n        for identity in user.identities:\n            if(identity.primary == True):\n                user_primary_email = identity.email\n                break\n        buyer_collection.primary_email = user_primary_email\n        buyer_collection_key = buyer_collection.put()\n        object_log = ObjectLog(parent=buyer_collection_key, agent=user_key, action='update', state='none', log=buyer_collection)\n        object_log.put()\n    \n    # Brise postojecu kolekciju korisnika\n    @ndb.transactional\n    def delete():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection.parent == agent).\n        object_log = ObjectLog(parent=buyer_collection_key, agent=user_key, action='delete', state='none')\n        object_log.put()\n        buyer_collection_key.delete()\n\n# done!\nclass BuyerCollectionStore(ndb.Model):\n    \n    # ancestor User\n    store = ndb.KeyProperty('1', kind=Store, required=True)\n    collections = ndb.KeyProperty('2', kind=BuyerCollection, repeated=True)# soft limit 500x\n    \n    _KIND = 20\n    \n    OBJECT_DEFAULT_STATE = 'none'\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'delete' : 3,\n    }\n    \n    # Dodaje novi store u korisnikovu listu i odredjuje clanstvo u kolekcijama korisnika\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        buyer_collection_store = BuyerCollectionStore(parent=user_key, store='7464536', collections=['1234'])\n        buyer_collection_store_key = buyer_collection_store.put()\n        object_log = ObjectLog(parent=buyer_collection_store_key, agent=user_key, action='create', state='none', log=buyer_collection_store)\n        object_log.put()\n        # izaziva se update AggregateBuyerCollectionCatalog preko task queue\n    \n    # Menja clanstvo store u kolekcijama korisnika\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection_store.parent == agent).\n        buyer_collection_store.collections = ['1234', '56433']\n        buyer_collection_store_key = buyer_collection_store.put()\n        object_log = ObjectLog(parent=buyer_collection_store_key, agent=user_key, action='update', state='none', log=buyer_collection_store)\n        object_log.put()\n        # izaziva se update AggregateBuyerCollectionCatalog preko task queue\n    \n    # Brise store iz korisnikove liste\n    @ndb.transactional\n    def delete():\n        # ovu akciju moze izvrsiti samo entity owner (buyer_collection_store.parent == agent).\n        object_log = ObjectLog(parent=buyer_collection_store_key, agent=user_key, action='delete', state='none')\n        object_log.put()\n        buyer_collection_store_key.delete()\n        # izaziva se update AggregateBuyerCollectionCatalog preko task queue\n        # ndb.delete_multi(AggregateBuyerCollectionCatalog.query(AggregateBuyerCollectionCatalog.store == buyer_collection_store.store, ancestor=user_key))\n\n# done! contention se moze zaobici ako write-ovi na ove entitete budu explicitno izolovani preko task queue\nclass AggregateBuyerCollectionCatalog(ndb.Model):\n    \n    # ancestor User\n    # not logged\n    # task queue radi agregaciju prilikom nekih promena na store-u\n    # mogao bi da se uvede index na collections radi filtera: AggregateBuyerCollectionCatalog.collections = 'collection', \n    # ovo moze biti dobra situacija za upotrebu MapReduce ??\n    # composite index: ancestor:yes - catalog_published_date:desc\n    store = ndb.KeyProperty('1', kind=Store, required=True)\n    collections = ndb.KeyProperty('2', kind=BuyerCollection, repeated=True, indexed=False)# soft limit 500x\n    catalog = ndb.KeyProperty('3', kind=Catalog, required=True, indexed=False)\n    catalog_cover = blobstore.BlobKeyProperty('4', required=True, indexed=False)# blob ce se implementirati na GCS\n    catalog_published_date = ndb.DateTimeProperty('5', required=True)\n\n################################################################################\n# USER REQUEST - 2\n################################################################################\n\n# done!\nclass FeedbackRequest(ndb.Model):\n    \n    # ancestor User\n    # ako hocemo da dozvolimo sva sortiranja, i dodatni filter po state-u uz sortiranje, onda nam trebaju slecedi indexi\n    # composite index:\n    # ancestor:yes - updated:desc; ancestor:yes - created:desc;\n    # ancestor:yes - state,updated:desc; ancestor:yes - state,created:desc\n    reference = ndb.StringProperty('1', required=True, indexed=False)\n    state = ndb.IntegerProperty('2', required=True)\n    updated = ndb.DateTimeProperty('3', auto_now=True, required=True)\n    created = ndb.DateTimeProperty('4', auto_now_add=True, required=True)\n    \n    # primer helper funkcije u slucajevima gde se ne koristi ancestor mehanizam za pristup relacijama\n    @property\n    def logs(self):\n      return ObjectLog.query(ancestor = self.key())\n    \n    _KIND = 8\n    \n    OBJECT_DEFAULT_STATE = 'new'\n    \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state\n        # ne znam da li je predvidjeno ovde da moze biti vise tranzicija/akcija koje vode do istog state-a,\n        # sto ce biti slucaj sa verovatno mnogim modelima.\n        # broj 0 je rezervisan za state none (Stateless Models) i ne koristi se za definiciju validnih state-ova\n        'new' : (1, ),\n        'reviewing' : (2, ),\n        'duplicate' : (3, ),\n        'accepted' : (4, ),\n        'dismissed' : (5, ),\n    }\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'review' : 3,\n       'close' : 4,\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'review' : {\n            'from' : ('new',),\n            'to' : ('reviewing',),\n         },\n        'close' : {\n           'from' : ('reviewing', ),\n           'to'   : ('duplicate', 'accepted', 'dismissed',),\n        },\n    }\n    \n    # Ova akcija sluzi za slanje feedback-a miraclestyle timu od strane krajnjih korisnika.\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        feedback_request = FeedbackRequest(parent=user_key, reference='https://www,miraclestyle.com/...', state='new')\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=user_key, action='create', state=feedback_request.state, message='poruka od agenta - obavezno polje!')\n        object_log.put()\n    \n    # Ova akcija sluzi za insert ObjectLog-a koji je descendant FeedbackRequest entitetu.\n    # Insertom ObjectLog-a dozvoljeno je unosenje poruke (i privatnog komentara), sto je i smisao ove akcije.\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'update-FeedbackRequest'. / ? # ovu akciju moze izvrsiti samo entity owner (feedback_request.parent == agent) ili agent koji ima globalnu dozvolu 'update-FeedbackRequest'.\n        # Radi se update FeedbackRequest-a bez izmena na bilo koji prop. (u cilju izazivanja promene na FeedbackRequest.updated prop.)\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=agent_key, action='update', state=feedback_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje FeedbackRequest entiteta u 'reviewing'.\n    @ndb.transactional\n    def review():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'review-FeedbackRequest'.\n        # akcija se moze pozvati samo ako je feedback_request.state == 'new'.\n        feedback_request.state = 'reviewing'\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=agent_key, action='review', state=feedback_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje FeedbackRequest entiteta u 'duplicate', 'accepted', ili 'dismissed'.\n    @ndb.transactional\n    def close():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'close-FeedbackRequest'.\n        # akcija se moze pozvati samo ako je feedback_request.state == 'reviewing'.\n        feedback_request.state = 'duplicate' | 'accepted' | 'dismissed'\n        feedback_request_key = feedback_request.put()\n        object_log = ObjectLog(parent=feedback_request_key, agent=agent_key, action='close', state=feedback_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n\n# done!\nclass SupportRequest(ndb.Model):\n    \n    # ancestor User\n    # ako uopste bude vidljivo useru onda mozemo razmatrati indexing\n    # ako hocemo da dozvolimo sva sortiranja, i dodatni filter po state-u uz sortiranje, onda nam trebaju slecedi indexi\n    # composite index:\n    # ancestor:yes - updated:desc; ancestor:yes - created:desc;\n    # ancestor:yes - state,updated:desc; ancestor:yes - state,created:desc\n    reference = ndb.StringProperty('1', required=True, indexed=False)\n    state = ndb.IntegerProperty('2', required=True)\n    updated = ndb.DateTimeProperty('3', auto_now=True, required=True)\n    created = ndb.DateTimeProperty('4', auto_now_add=True, required=True)\n    \n    _KIND = 9\n    \n    OBJECT_DEFAULT_STATE = 'new'\n    \n    OBJECT_STATES = {\n        # tuple represents (state_code, transition_name)\n        # second value represents which transition will be called for changing the state\n        # ne znam da li je predvidjeno ovde da moze biti vise tranzicija/akcija koje vode do istog state-a,\n        # sto ce biti slucaj sa verovatno mnogim modelima.\n        # broj 0 je rezervisan za state none (Stateless Models) i ne koristi se za definiciju validnih state-ova\n        'new' : (1, ),\n        'opened' : (2, ),\n        'awaiting_closure' : (3, ),\n        'closed' : (4, ),\n    }\n    \n    OBJECT_ACTIONS = {\n       'create' : 1,\n       'update' : 2,\n       'open' : 3,\n       'propose_close' : 4,\n       'close' : 5,\n    }\n    \n    OBJECT_TRANSITIONS = {\n        'open' : {\n            'from' : ('new',),\n            'to' : ('opened',),\n         },\n        'propose_close' : {\n           'from' : ('opened', ),\n           'to'   : ('awaiting_closure',),\n        },\n        'close' : {\n           'from' : ('opened', 'awaiting_closure',),\n           'to'   : ('closed',),\n        },\n    }\n    \n    # Ova akcija krajnjem korisniku sluzi za pravljenje zahteva za pomoc (ticket-a) od miraclestyle tima.\n    @ndb.transactional\n    def create():\n        # ovu akciju moze izvrsiti samo registrovani autenticirani agent.\n        support_request = SupportRequest(parent=user_key, reference='https://www,miraclestyle.com/...', state='new')\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=user_key, action='create', state=support_request.state, message='poruka od agenta - obavezno polje!')\n        object_log.put()\n    \n    # Ova akcija sluzi za insert ObjectLog-a koji je descendant SupportRequest entitetu.\n    # Insertom ObjectLog-a dozvoljeno je unosenje poruke (i privatnog komentara), sto je i smisao ove akcije.\n    @ndb.transactional\n    def update():\n        # ovu akciju moze izvrsiti samo entity owner (support_request.parent == agent) ili agent koji ima globalnu dozvolu 'update-SupportRequest'\n        # Radi se update SupportRequest-a bez izmena na bilo koji prop. (u cilju izazivanja promene na SupportRequest.updated prop.)\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='update', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje SupportRequest entiteta u 'opened'.\n    @ndb.transactional\n    def open():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'open-SupportRequest'.\n        # akcija se moze pozvati samo ako je support_request.state == 'new'.\n        support_request.state = 'opened'\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='open', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom privilegovani/administrativni agent menja stanje SupportRequest entiteta u 'awaiting_closure'.\n    @ndb.transactional\n    def propose_close():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'propose_close-SupportRequest'.\n        # akcija se moze pozvati samo ako je support_request.state == 'opened'.\n        support_request.state = 'awaiting_closure'\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='propose_close', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n    \n    # Ovom akcijom agent menja stanje SupportRequest entiteta u 'closed'.\n    @ndb.transactional\n    def close():\n        # ovu akciju moze izvrsiti samo entity owner (support_request.parent == agent) ili agent koji ima globalnu dozvolu 'close-SupportRequest' (sto ce verovatno imati sistemski account koji ce preko cron-a izvrsiti akciju).\n        # akcija se moze pozvati samo ako je support_request.state == 'opened' ili support_request.state == 'awaiting_closure'.\n        support_request.state = 'closed'\n        support_request_key = support_request.put()\n        object_log = ObjectLog(parent=support_request_key, agent=agent_key, action='close', state=support_request.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima/non-owner-ima) - obavezno polje!')\n        object_log.put()\n\n"],[0,"################"]],"start1":31857,"start2":31857,"length1":32,"length2":26365}]],"length":77346,"saved":false}
{"ts":1378922956999,"patch":[[{"diffs":[[0," ),\n"],[-1,"        'terminated' : (3, ),\n"],[0,"    }\n"],[1,""],[0,"    "]],"start1":4037,"start2":4037,"length1":44,"length2":14},{"diffs":[[0,"   '"],[-1,"terminate' : 4,\n       'activate_suspended' : 5,\n       'activate_terminated' : 6"],[1,"activate' : 4"],[0,",\n  "]],"start1":4143,"start2":4143,"length1":89,"length2":21}]],"length":77248,"saved":false}
{"ts":1378922989612,"patch":[[{"diffs":[[0,"activate"],[-1,"_suspended"],[0,""],[1,""],[0,"' : {\n  "]],"start1":4209,"start2":4209,"length1":26,"length2":16},{"diffs":[[0,"    "],[-1," 'activate_terminated' : {\n            'from' : ('terminated',),\n            'to' : ('active',),\n         },\n        'suspend' : {\n           'from' : ('active', ),\n           'to'   : ('suspended',),\n        },\n        'terminate' : {\n           'from' : ('active', 'suspended'),\n           'to'   : ('terminat"],[1,"'suspend' : {\n           'from' : ('active', ),\n           'to'   : ('suspend"],[0,"ed',"]],"start1":4308,"start2":4308,"length1":319,"length2":85}]],"length":77004,"saved":false}
{"ts":1378923025325,"patch":[[{"diffs":[[0,"   \n"],[-1,"    # Ova akcija terminira aktivnu ili suspendovanu domenu. Ovde cemo dalje opisati posledice terminacije\n    @ndb.transactional\n    def terminate():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'terminate-Domain'.\n        # akcija se moze pozvati samo ako je domain.state == 'active' ili domain.state == 'suspended'.\n        # ova akcija treba biti mozda drugacije protected od ostalih akcija, to se moze resiti na dva nacina:\n        # prvi nacin je da se domain administrativnim userima zabrani mogucnost dodavanja dozvole 'terminate-Domain' u listi dozvola na domain-specific Rolama\n        # drugi nacin je da se ova metoda drugacije evaluira, tako da ignorise proveru domain-specific Rola\n        domain.state = 'terminated'\n        domain_key = domain.put()\n        object_log = ObjectLog(parent=domain_key, agent=agent_key, action='terminate', state=domain.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()\n    \n"],[0,"    "]],"start1":6880,"start2":6880,"length1":1074,"length2":8},{"diffs":[[0,"activate"],[-1,"_suspended"],[0,"():\n    "]],"start1":7007,"start2":7007,"length1":26,"length2":16},{"diffs":[[0,"ut()"],[-1,"\n    \n    # Ova akcija aktivira terminiranu domenu. Ovde cemo dalje opisati posledice aktivacije\n    @ndb.transactional\n    def activate_terminated():\n        # ovu akciju moze izvrsiti samo agent koji ima globalnu dozvolu 'activate_terminated-Domain'.\n        # akcija se moze pozvati samo ako je domain.state == 'terminated'.\n        # ova akcija treba biti mozda drugacije protected od ostalih akcija, to se moze resiti na dva nacina:\n        # prvi nacin je da se domain administrativnim userima zabrani mogucnost dodavanja dozvole 'activate_terminated-Domain' u listi dozvola na domain-specific Rolama\n        # drugi nacin je da se ova metoda drugacije evaluira, tako da ignorise proveru domain-specific Rola\n        domain.state = 'active'\n        domain_key = domain.put()\n        object_log = ObjectLog(parent=domain_key, agent=agent_key, action='activate_terminated', state=domain.state, message='poruka od agenta - obavezno polje!', note='privatni komentar agenta (dostupan samo privilegovanim agentima) - obavezno polje!')\n        object_log.put()"],[0,"\n\n# "]],"start1":7544,"start2":7544,"length1":1067,"length2":8}]],"length":74869,"saved":false}
{"ts":1378923117210,"patch":[[{"diffs":[[0," = Role("],[-1,"parent"],[1,"namespace"],[0,"=domain_"]],"start1":4984,"start2":4984,"length1":22,"length2":25}]],"length":74872,"saved":false}
{"ts":1378923151131,"patch":[[{"diffs":[[0,"t()\n"],[-1,"        #object_log = ObjectLog(parent=role_user_key, agent=user_key, action='accept', state=role_user.state, log=role_user)\n        #object_log.put()\n"],[0,"    "]],"start1":5216,"start2":5216,"length1":159,"length2":8}]],"length":74721,"saved":false}
{"ts":1378923170763,"patch":[[{"diffs":[[0,"r.put()\n        "],[-1,"sub"],[1,"user"],[0,"_role = Role(nam"]],"start1":5212,"start2":5212,"length1":35,"length2":36},{"diffs":[[0,"y=True)\n        "],[-1,"sub"],[1,"user"],[0,"_role.put()\n    "]],"start1":5362,"start2":5362,"length1":35,"length2":36}]],"length":74723,"saved":false}
{"ts":1378923456971,"patch":[[{"diffs":[[0,"activate"],[-1,"_suspended"],[0,"-Domain'"]],"start1":6953,"start2":6953,"length1":26,"length2":16}]],"length":74713,"saved":false}
{"ts":1378923469849,"patch":[[{"diffs":[[0,"vate"],[-1,"_suspended"],[0,"', s"]],"start1":7194,"start2":7194,"length1":18,"length2":8}]],"length":74703,"saved":false}
{"ts":1378923560276,"patch":[[{"diffs":[[0,"main"],[-1,"/'MIRACLESTYLE')\n    # Role permissions affect Domain and it's related entities, with exception to Roles in 'MIRACLESTYLE' namespace.\n    # Roles in 'MIRACLESTYLE' namespace globally affect Miraclestyle Application and all of it's related entities."],[1,")"],[0,"\n   "]],"start1":7444,"start2":7444,"length1":256,"length2":9}]],"length":74456,"saved":false}
{"ts":1378923577055,"patch":[[{"diffs":[[0,"rolu"],[-1," domene, ili globalnu rolu"],[0,"\n   "]],"start1":8197,"start2":8197,"length1":34,"length2":8}]],"length":74430,"saved":false}
{"ts":1378923591928,"patch":[[{"diffs":[[0,"'. \n"],[-1,"        # u slucaju kreiranja Role u 'MIRACLESTYLE' domeni, agent mora biti Application Admin (users.is_current_user_admin()).\n"],[0,"    "]],"start1":8334,"start2":8334,"length1":135,"length2":8},{"diffs":[[0,"e'.\n"],[-1,"        # domena 'MIRACLESTYLE' je uvek evaluated 'active'\n"],[0,"    "]],"start1":8405,"start2":8405,"length1":67,"length2":8}]],"length":74244,"saved":false}
{"ts":1378923643044,"patch":[[{"diffs":[[0," = Role("],[-1,"namespace=domain_key, "],[0,"name='St"]],"start1":8421,"start2":8421,"length1":38,"length2":16}]],"length":74222,"saved":false}
{"ts":1378923689210,"patch":[[{"diffs":[[0,"rolu"],[-1," domene, ili globalnu rolu"],[0,"\n   "]],"start1":8754,"start2":8754,"length1":34,"length2":8},{"diffs":[[0,"():\n"],[-1,"        # (u slucaju da agent treba azurirati globalne Role imacemo problem posto bi globalna dozvola 'update-Role'\n        # po trenutnom konceptu znacila da user sa ovom dozvolom moze u svakoj domeni raditi 'update-Role').\n"],[0,"    "]],"start1":8796,"start2":8796,"length1":233,"length2":8}]],"length":73971,"saved":false}
{"contributors":[],"silentsave":false,"ts":1378926067612,"patch":[[{"diffs":[[0,"ima "],[-1,"za"],[1,"u"],[0," async "],[-1,"oper"],[1,"radi optimiz"],[0,"acij"]],"start1":9334,"start2":9334,"length1":21,"length2":28}]],"length":73978,"saved":false}
{"ts":1378926213850,"patch":[[{"diffs":[[0,")))\n            "],[-1,"sub"],[1,"user"],[0,"_role = key.get("]],"start1":9483,"start2":9483,"length1":35,"length2":36},{"diffs":[[0,"            "],[-1,"sub"],[1,"user"],[0,"_role.name ="]],"start1":9521,"start2":9521,"length1":27,"length2":28},{"diffs":[[0,"            "],[-1,"sub"],[1,"user"],[0,"_role.permis"]],"start1":9560,"start2":9560,"length1":27,"length2":28},{"diffs":[[0,"ons\n            "],[-1,"sub"],[1,"user"],[0,"_role.put()\n    "]],"start1":9609,"start2":9609,"length1":35,"length2":36}]],"length":73982,"saved":false}
{"ts":1378926276591,"patch":[[{"diffs":[[0,"rolu"],[-1," domene, ili globalnu rolu."],[0,"\n   "]],"start1":9668,"start2":9668,"length1":35,"length2":8},{"diffs":[[0,"():\n"],[-1,"        # (u slucaju da agent treba brisati globalne Role imacemo problem posto bi globalna dozvola 'delete-Role'\n        # po trenutnom konceptu znacila da user sa ovom dozvolom moze u svakoj domeni raditi 'delete-Role').\n"],[0,"    "]],"start1":9710,"start2":9710,"length1":231,"length2":8}]],"length":73732,"saved":false}
{"ts":1378926375850,"patch":[[{"diffs":[[0,"tor Role"],[-1,"\n    #"],[1," (namespace Domain) -"],[0," id = st"]],"start1":10409,"start2":10409,"length1":22,"length2":37}]],"length":73747,"saved":false}
{"ts":1378926399826,"patch":[[{"diffs":[[0,"d = str("],[-1,"user"],[1,"role"],[0,"_key.id("]],"start1":10440,"start2":10440,"length1":20,"length2":20}]],"length":73747,"saved":false}
{"ts":1378926437979,"patch":[[{"diffs":[[0," - id = str("],[-1,"role"],[1,"user"],[0,"_key.id())\n "]],"start1":10436,"start2":10436,"length1":28,"length2":28}]],"length":73747,"saved":false}
{"ts":1378926448711,"patch":[[{"diffs":[[0,"():\n"],[-1,"        # (u slucaju da se user treba invite na globalnu Rolu imacemo problem posto bi globalna dozvola 'invite-RoleUser'\n        # po trenutnom konceptu znacila da user sa ovom dozvolom moze u svakoj domeni raditi 'invite').\n"],[0,"    "]],"start1":11604,"start2":11604,"length1":234,"length2":8}]],"length":73521,"saved":false}
{"ts":1378926535066,"patch":[[{"diffs":[[0,"rolu"],[-1," domene, ili globalnu rolu"],[0,"\n   "]],"start1":11536,"start2":11536,"length1":34,"length2":8}]],"length":73495,"saved":false}
{"ts":1378926539481,"patch":[[{"diffs":[[0,"role"],[-1," domene, ili globalne role."],[0,"\n   "]],"start1":12145,"start2":12145,"length1":35,"length2":8}]],"length":73468,"saved":false}
{"ts":1378926544784,"patch":[[{"diffs":[[0,"():\n"],[-1,"        # (u slucaju da se user treba remove sa globalne Role imacemo problem posto bi globalna dozvola 'remove-RoleUser'\n        # po trenutnom konceptu znacila da user sa ovom dozvolom moze u svakoj domeni raditi 'remove').\n"],[0,"    "]],"start1":12187,"start2":12187,"length1":234,"length2":8}]],"length":73242,"saved":false}
{"ts":1378926672318,"patch":[[{"diffs":[[0,"user == agent).\n"],[1,"        # agent koji je referenciran u domain.primary_contact prop. ne moze izgubiti dozvole za upravljanje domenom\n"],[0,"        # akcija"]],"start1":12342,"start2":12342,"length1":32,"length2":148}]],"length":73358,"saved":false}
{"ts":1378926897247,"patch":[[{"diffs":[[0,"ete "],[1,"ne"],[0,"ce "],[-1,"fail"],[1,"uspeti"],[0," uko"]],"start1":12816,"start2":12816,"length1":15,"length2":19},{"diffs":[[0,"iko "],[-1,"nije napravljen entitet sa tim kljucem"],[1,"entitet ne postoji"],[0,", na"]],"start1":12836,"start2":12836,"length1":46,"length2":26}]],"length":73342,"saved":false}
{"ts":1378927005808,"patch":[[{"diffs":[[0,"rolu"],[-1," (lokalne ili globalne - \"MIRACLESTYLE\") domene"],[0,"\n   "]],"start1":12963,"start2":12963,"length1":55,"length2":8}]],"length":73295,"saved":false}
{"ts":1378927078563,"patch":[[{"diffs":[[0,"er.user == agent"],[1,"_key"],[0,").\n        # akc"]],"start1":13095,"start2":13095,"length1":32,"length2":36}]],"length":73299,"saved":false}
{"ts":1378927087487,"patch":[[{"diffs":[[0,"== agent"],[-1,"_key"],[0,").\n     "]],"start1":13103,"start2":13103,"length1":20,"length2":16}]],"length":73295,"saved":false}
{"ts":1378927150296,"patch":[[{"diffs":[[0,"ccept', "],[1,"state="],[0,"role_use"]],"start1":13341,"start2":13341,"length1":16,"length2":22}]],"length":73301,"saved":false}
{"ts":1378927214128,"patch":[[{"diffs":[[0,"t()\n        "],[-1,"sub"],[1,"user"],[0,"_role = Role"]],"start1":13393,"start2":13393,"length1":27,"length2":28},{"diffs":[[0,"    "],[-1,"sub"],[1,"user"],[0,"_rol"]],"start1":13547,"start2":13547,"length1":11,"length2":12}]],"length":73303,"saved":false}
{"ts":1378927453448,"patch":[[{"diffs":[[0,"nt=role_key,"],[1," id='123673472829',"],[0," user='12367"]],"start1":11784,"start2":11784,"length1":24,"length2":43},{"diffs":[[0," = Role("],[-1,"namespace=domain_key, "],[0,"parent=r"]],"start1":13433,"start2":13433,"length1":38,"length2":16}]],"length":73300,"saved":false}
{"ts":1378927587673,"patch":[[{"diffs":[[0," domenom"],[1,"."],[0,"\n       "]],"start1":12484,"start2":12484,"length1":16,"length2":17}]],"length":73301,"saved":false}
{"ts":1378927676619,"patch":[[{"diffs":[[0," \n    # root"],[1," (namespace Domain)"],[0,"\n    name = "]],"start1":13629,"start2":13629,"length1":24,"length2":43}]],"length":73320,"saved":false}
{"ts":1378927722624,"patch":[[{"diffs":[[0,"###\n\n# done!"],[1," - ovde ce nam trebati kontrola"],[0,"\nclass Domai"]],"start1":3138,"start2":3138,"length1":24,"length2":55}]],"length":73351,"saved":false}
{"ts":1378927762222,"patch":[[{"diffs":[[0,"g.put()\n\n# done!"],[1," ovo cemo iskoristiti za globalne dozvole"],[0,"\nclass Role(ndb."]],"start1":7406,"start2":7406,"length1":32,"length2":73},{"diffs":[[0,"e()\n\n# done!"],[1," ovo cemo iskoristiti za globalne dozvole"],[0,"\nclass RoleU"]],"start1":10425,"start2":10425,"length1":24,"length2":65}]],"length":73433,"saved":false}
